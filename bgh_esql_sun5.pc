/*************************************************************/
/*                                                           */
/* LH-Specification GmbH 1996                                */
/* All rights reserved.                                      */
/* Copying of this software or parts of this software is a   */
/* violation of German and International laws and will be    */
/* prosecuted.                                               */
/*                                                           */
/* PROJECT  : BGH                                            */
/*                                                           */
/* FILE     : bgh_esql.pc                                    */
/*                                                           */
/* AUTHOR   : Trajan Rotaru                                  */
/*                                                           */
/* CREATED  : Mar. 1996                                      */
/*                                                           */
/* MODIFIED :                                                */
/* 13.12.96     B. Michler  New declaration for long varraw  */
/*			    according to oracle example	     */
/*			    (defect 21406)		     */
/* 12.12.96	B. Michler  Do NOT select with 'cslevel' in  */
/*			    'WHERE' statement of secondary   */
/*			    cursor			     */
/* 05.11.96	B. Michler  Insert contract id when writing  */
/*			    bill image 			     */
/* 14.10.96	B. Michler  String SCCS_VERSION for 	     */
/*			    version.sh			     */
/* 16.07.96	B. Michler  primary cursor is not hardcoded  */
/*                          to INV_TYPE any more, type is    */
/*                          passed as parameter              */
/* 09.07.96	B. Michler  second cursor selects only       */
/*                          elements with given CSLEVEL      */
/* 08.07.96	B. Michler  'GetDocTables': always allocate  */
/*                          memory for at least one element  */
/*                          and set it to last element       */
/* 26.06.96	B. Michler  additional parameter of type     */
/* 			    stDBCOL * for database access    */
/*			    routines			     */
/*                                                           */
/* ABSTRACT : All embedded-sql programs for BGH              */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* This file contains all the defines and statements used    */
/* to interact with the database.                            */
/*                                                           */
/* ROUTINES DEFINED HERE USED ONLY IN THIS FILE:             */
/*                                                           */
/*                         sqlerror()                        */
/*            ReadAgainFromDatabase()                        */
/*              foiHandleTestCursor()                        */
/*                                                           */
/* ROUTINES DEFINED HERE USED ELSEWHERE:                     */
/*                                                           */
/*              GetTimmFromDatabase()                        */
/*              GetTestFromDatabase()                        */
/*           GetVersionFromDatabase()                        */
/*     GetBaseDirectoryFromDatabase()                        */
/*    GetProcessProgramFromDatabase()                        */
/*        GetCheckBatchFromDatabase()                        */
/*              PutBillIntoDatabase()                        */
/*                foiHandleDatabase()                        */
/*                    foiCommitWork()                        */
/*                  foiRollbackWork()                        */
/*                        MarkWithX()                        */
/*                        foiEraseX()                        */
/*                    foiPutOnStack()                        */
/*                  foiMarkCustomer()                        */
/*                    MarkProcessed()                        */
/*                        FreeStack()                        */
/*                                                           */
/*************************************************************/

/*************************************************************/
/*                                                           */
/* REMARK:                                                   */
/*                                                           */
/* This file must be compiled in mode = oracle!              */
/* It is not ANSI-compatible.                                */
/*                                                           */
/* To change the BGH to be ANSI-compatible in regard of      */
/* embedded sql the following had to be changed:             */
/*                                                           */
/* The define SQL_NODATAFOUND from 1403 to 100.              */
/*                                                           */
/* The cursor has to be closed and reopened after/before     */
/* the commit.                                               */
/*                                                           */
/* Probably some of the operations with strings have to      */
/* be changed.                                               */
/*                                                           */
/*                                                           */
/*************************************************************/
#define O

#define SQLCA_INIT

#include <stdio.h>
#include <stdlib.h>
#include <string.h>             /* used for strncmp          */
#include <time.h>               /* time information          */

#include "./include/bgh.h"
#include "./include/protos.h"
#include "./include/bgh_esql.h"
#include "com_defs.h"		/* define for BSCS_PATH 	*/
#include "com_login.h"		/* LHS-BSCS-library: declarations and */
				/* definitions common for PROJECT     */

#include "workparval.h"

/*************************************************************/
/* defines for embedded sql:                                 */
/*************************************************************/
#define TRACESQL	0

/*  No data found would be 100 in ANSI-mode                  */
#define SQL_NODATAFOUND    1403
#define SQL_STRINGDATA_RIGHTTRUNCATED    1406
#define ROLLBACK_FAILED      89
#define SQL_INVCOLUMN	   -904

#define NULL_VALUE        -1    /* indicator-var value if a  */
                                /* NULL occurred             */
#define NULL_STR       "NULL"   /* to print to log file      */


/*************************************************************/
/* Macros to change SQL-Varchars to C-Strings and vic-versa. */
/* Varchars are always written to C-strings before the are   */
/* printed or handled somehow.                               */
/*************************************************************/

#define SET_VARCHAR(var, val, null) if (null == -1) {var[0] = '\0';} else {STRCPY_FROM_ORA(var, val);}
#define SET_LONG(var, val, null) if (null == -1) {var = -1;} else {var = val;}
#define SET_INT(var, val, null) if (null == -1) {var = -1;} else {var = val;}

#define STRCPY_TO_ORA(dest, source)	\
        {				\
           (dest).len = strlen(source);	\
           (void)memcpy((void*)(dest).arr, (void*)(source), (size_t)(dest).len); \
	}
#define STRCPY_FROM_ORA(dest, source)	\
        { 				\
          (void)memcpy((void*)(dest), (void*)(source).arr, (size_t)(source).len); \
          (dest)[(source).len] = '\0';	\
	}

/*************************************************************/
/* Oracle options                                            */
/*************************************************************/

EXEC ORACLE OPTION (hold_cursor=yes);

/**************************************************************/
/* Next defines handle the parameter exchange between         */
/*  Oracle and programs.                                      */
/**************************************************************/

typedef struct
{
    long          len;
    unsigned char arr[1];
} tLONGVARCHAR;

typedef tLONGVARCHAR *tLONGVARCHARPTR;

typedef struct 
{
    long           len;
    unsigned char  buf[1];
    
} tLONGRAW;

typedef tLONGRAW *tLONGRAWPTR;

/* declare section *******************************************/
EXEC SQL BEGIN DECLARE SECTION;

long DEFAULT_BLOB_SIZE = CONST_DEFAULT_BLOB_SIZE;

EXEC SQL TYPE tLONGVARCHARPTR IS long varchar(2000000000) REFERENCE;

#ifdef BSCS4
/*
 * the same as above with PROC16, but BSCS4 only supports oracle 7.3.x
 * which in fact does not support PROC16 ...
 */
/*
** Defect 21406:
** The former approach with a virtual length 0 for the oracle type
** does not work any more with oracle 7.3.x
** This approach is due to an example of oracle, it tells oracle
** to allow a max. length of almost 1 Gigabyte, the real length
** is passed afterwards!
*/
EXEC SQL TYPE tLONGRAWPTR IS LONG VARRAW(1000000000) REFERENCE;
#endif

/* host-vars for logon */
VARCHAR       O_username[50];
VARCHAR       O_password[50];
VARCHAR       O_db_name[50];
VARCHAR       O_connect_string[50];



/* for host-vars which are used to copy data from table     */
/* document_all to bill_images, the name used in document_  */
/* all is used                                              */

/* vars for document_all and for bill_images                */

/* variables used to remember sth. globally */
VARCHAR    O_rowid_inv[20];     /* rowid for current invoice    */
VARCHAR    O_rowid_curr[20];    /* rowid after last SQL-command */
VARCHAR    O_rowid_stack[20];   /* current rowid on stack       */
long       O_usage_prim;        /* for usage INV_TYPE        */
long 	   O_usage_lgn_type;	/* for LGN_TYPE		     */
VARCHAR    O_date_created[15];
VARCHAR    O_date_inserted[15];
long       O_customer_id;
VARCHAR    O_cust_processed[2];
long	   O_unique_id;		/* a unique id from time 	*/
long	   O_write_id;		/* a unique id from time (writing)*/

long       O_BghId;		/* Id of the running BGH, parallel running BGHs only */


/* variables filled by sql statements but never read */
VARCHAR    O_contr_group[2];
short      O_contr_group_ind;   /* NULL indicator            */

/* temporary variables */
long       O_usage_curr;        /* for current usage         */

long       O_contract_id;
short      O_contract_id_ind;   /* NULL indicator            */
long       O_ohxact;
short      O_ohxact_ind;        /* NULL indicator            */
long       O_default_document_size;
long       O_document_size;
tLONGVARCHARPTR O_document;
short      O_document_ind;      /* string data right         */
                                /* truncated indicator       */
VARCHAR    O_processed[2];
short      O_processed_ind;     /* NULL indicator            */

/* host_vars for bill-images                                 */
VARCHAR    O_bi_type[2];            /* timm_type for image          */
char      *O_bi_image;              /* the image                    */
VARCHAR    O_bi_image_process[80];  /* image-processing programname */
VARCHAR    O_bi_extension[4];       /* file-extension               */


/* host_vars for test, version-check enabled, BGH-version_number  */
/* and BGH-base-directory                                         */

VARCHAR    T_date_created[15];  /* test document_all:date_created */
int        T_type_id;           /* test document_all:type_id      */
VARCHAR    T_type_shdes[5];     /* test doc_types:type_shdes      */
int        T_count;             /* test count                     */

VARCHAR    V_modulename[4];     /* version-number app_modules:modulename */
VARCHAR    V_version[20];       /* version-number app_modules:version    */
short      V_version_ind;       /* string data right         */
                                /* truncated indicator       */
VARCHAR    V_vcheck_b[2];       /* version-check enabled for */
                                /* batch-modules in table    */
                                /* bscsproject:vcheck_b      */

int        B_cfcode;            /* unique system parameter ID      */
VARCHAR    B_cfvalue[128];      /* base directory mpscftab:cfvalue */
short      B_cfvalue_ind;       /* string data right         */
                                /* truncated indicator       */

int        PP_cfcode;           /* unique system parameter ID       */
VARCHAR    PP_cfvalue[128];     /* process-program mpscftab:cfvalue */
short      PP_cfvalue_ind;      /* string data right         */
                                /* truncated indicator       */

#ifdef BSCS4
VARCHAR	   	O_bill_ins_cd[100]; /* bill insertions for envelopping */
short		O_bill_ins_ind;
VARCHAR	   	O_cslevel[2];	/* customer level */
short		O_cslevel_ind;

long	   	O_bitypnr;	/* Bill type as number */
long	   	O_type_id;
long	   	O_itype_id;
long	   	O_cust_id;
VARCHAR	   	O_gen_this_msg[2];
short	   	O_gen_ind;
long	   	O_copies;
VARCHAR	   	O_shdes[6];

long	   	O_imagesize;
VARCHAR    	O_contrgroup[2];
short		O_contrgr_ind;
VARCHAR    	O_testbrun[2];
short		O_testbr_ind;
VARCHAR    	O_bins_code[100];
tLONGRAWPTR   	O_rawimage;
long            O_NumberOfCustomers;  /* Number of Customers to procedd */

#endif

/*
 * DCS 1800 PTK Centertel project
 */

VARCHAR O_plmnname[13];
VARCHAR O_country[21];

/*
 * dealer comission handling
 */

long O_dealer_customer_id;
long O_dealer_co_id;
VARCHAR O_dealer_ohrefnum[31];
VARCHAR O_dealer_ohrefdate[11];
VARCHAR O_dealer_ohentdate[11];
double O_dealer_air_time_value;

/*
  typedef struct {
  char szPrefix[21];
  char szDest[31];
  char szZone[11];
  int  lIndex;
  } stDest;
*/

VARCHAR O_prefix[21]; 
VARCHAR O_dest[31];
VARCHAR O_zone[11];
      
long O_tariff_zone_code;
long O_tariff_time_code;
long O_service_name_code;
long O_tariff_model_code;
long O_tariff_model_version;
long O_service_package_code;
VARCHAR O_des[31];

VARCHAR O_digits[19];

VARCHAR O_ccline1[41], O_ccline2[41], O_ccline3[41], O_ccline4[41], O_ccline5[41], O_cczip[16];
short O_ccline1_ind, O_ccline2_ind, O_ccline3_ind, O_ccline4_ind, O_ccline5_ind, O_cczip_ind; 


VARCHAR O_socsecno[21];
short O_socsecno_ind;

/*
 * Sim info
 */

VARCHAR     O_sim_custcode[21];
short       O_sim_custcode_ind;
long        O_sim_customer_id;
short       O_sim_customer_id_ind;
VARCHAR     O_sim_ccfname[40];
short       O_sim_ccfname_ind;
VARCHAR     O_sim_cclname[40];
short       O_sim_cclname_ind;
long        O_sim_co_id;
short       O_sim_co_id_ind;
VARCHAR     O_sim_co_activated[6];
short       O_sim_co_activated_ind;
VARCHAR     O_sim_subm_shdes[5]; 
short       O_sim_subm_shdes_ind;
VARCHAR     O_sim_subm_des[20];
short       O_sim_subm_des_ind;
VARCHAR     O_sim_dn_num[20];
short       O_sim_dn_num_ind;
VARCHAR     O_sim_cd_sm_num[50];
short       O_sim_cd_sm_num_ind;

/*
 * Struct customer
 */

VARCHAR     O_sim_cslevel[2];
short       O_sim_cslevel_ind;
VARCHAR     O_sim_paymntresp[2];
short       O_sim_paymntresp_ind;

/*
typedef struct {
  int  soiIndex;
  char sasnzCustcode[21];
  char sasnzCCFName[41];
  char sasnzCCLName[41];
  int  soiCoId;
  char sasnzCoActivated[7];
  char sasnzSubmShdes[6];
  char sasnzSubmDes[20];
  char sasnzDnNum[21];
  char sasnzCdSmNum[51];
} tostCustSim;
*/

/*
 * Struct for PRICEGROUP_ALL
 */

VARCHAR Oprice_group_code[16];
long    Oprice_group_seq_no;
VARCHAR Oprice_group_name[32];

/*
 * Struct 
 */

long    Opayment_type_id;
char    Opayment_type_code;
VARCHAR Opayment_type_name[32];

/*
 * Struct for BILL_MEDIUM
 */

long    Obill_medium_id;
VARCHAR Obill_medium_des[32];
VARCHAR Obill_medium_default[8];

short   Obill_medium_id_ind;
short   Obill_medium_des_ind;
short   Obill_medium_default_ind;

/*
 * Struct for MPDSCTAB values needed to identify market
 */

long    Oplmn_id;
short   Oplmn_id_ind;

long    Omarket_id;
short   Omarket_id_ind;

VARCHAR Omarket_des[60];
short   Omarket_des_ind;

VARCHAR Onetwork_des[12];
short   Onetwork_des_ind;


/* 
 * variables for WorkParVal 
 */

VARCHAR O_WParValDate[DATE_LEN];
VARCHAR O_WParValCode[PARVALCODE_LEN];
VARCHAR O_WParValCustomerId[PARVALCODE_LEN];
VARCHAR O_WParValCoId[PARVALCODE_LEN];
VARCHAR O_WParVal[PARVALTEXT_LEN];
VARCHAR O_WParValField1[PARVALTEXT_LEN];
VARCHAR O_WParValField2[PARVALTEXT_LEN];
VARCHAR O_WParValField3[PARVALTEXT_LEN];
VARCHAR O_WParValField4[PARVALTEXT_LEN];
VARCHAR O_WParValField5[PARVALTEXT_LEN];

short O_WParValDate_ind;
short O_WParValCode_ind;
short O_WParValCustomerId_ind;
short O_WParValCoId_ind;
short O_WParVal_ind;
short O_WParValField1_ind;
short O_WParValField2_ind;
short O_WParValField3_ind;
short O_WParValField4_ind;
short O_WParValField5_ind;



EXEC SQL END DECLARE SECTION;

/* Next variables are used to be filled with host-vars       */
static char      t_date_created[15];  /* to test db */
static char      t_type_shdes[6];     /* to test db */

EXEC SQL INCLUDE sqlca;
/*
EXEC SQL AT :O_db_name
    DECLARE Cmarket CURSOR FOR
     SELECT SCCODE, DES
       FROM MPDSCTAB
   ORDER BY DES;
*/

EXEC SQL AT :O_db_name
    DECLARE Cmarket CURSOR FOR
     SELECT SC.SCCODE, PL.PLCODE, SC.DES, PL.PLMNNAME
       FROM MPDPLTAB PL,
            MPDSCTAB SC
      WHERE PL.PLMNTYPE = 'H'
        AND PL.SCCODE = SC.SCCODE
   ORDER BY SC.DES;

EXEC SQL AT :O_db_name
    DECLARE Cbill_medium CURSOR FOR
     SELECT BM_ID, BM_DES, BM_DEFAULT
       FROM BILL_MEDIUM
   ORDER BY BM_ID;

EXEC SQL AT :O_db_name
    DECLARE Cpayment_type CURSOR FOR
     SELECT PAYMENT_ID, PAYMENTCODE, PAYMENTNAME
       FROM PAYMENTTYPE_ALL
   ORDER BY PAYMENTCODE;

EXEC SQL AT :O_db_name
    DECLARE Cprice_group CURSOR FOR
     SELECT PRGCODE, PRGSEQNUM, PRGNAME
       FROM PRICEGROUP_ALL
   ORDER BY PRGCODE;

EXEC SQL AT :O_db_name
    DECLARE Cdest CURSOR FOR
     SELECT PREFIX, DEST, ZONE
       FROM destination
   ORDER BY PREFIX;


/* Cursor for dispercing the customers to parallel running BGHs' */
EXEC SQL AT  :O_db_name
    DECLARE  Cbalance_cursor CURSOR FOR
     SELECT  customer_id
       FROM  document_all
      WHERE  type_id  in (:O_usage_prim)
        AND  processed_by_bgh IS null
   ORDER BY  sort_criteria, customer_id
        FOR  update of bgh_process;

#ifdef TEST

/* The cursor for read invoice from_database                 */
EXEC SQL AT  :O_db_name
    DECLARE  Cmain_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             customer_id,
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document
       FROM  document_all
      WHERE  type_id = :O_usage_prim 
        AND  bgh_process = :O_BghId
   ORDER BY  sort_criteria,customer_id;

/* The cursor for read a single-customer invoice from_database */
EXEC SQL AT  :O_db_name
    DECLARE  Csingle_main_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document
       FROM  document_all
      WHERE  customer_id= :O_customer_id
        AND  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
   ORDER BY  sort_criteria;

/* The cursor for read from database invoice-dependent documents */

EXEC SQL AT  :O_db_name
    DECLARE  Csecond_cursor CURSOR FOR
     SELECT  rowid,
             document_size,
             document,
             contract_id
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  bgh_process = :O_unique_id;
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

EXEC SQL AT  :O_db_name
    DECLARE  Csecond_common_cursor CURSOR FOR
     SELECT  rowid,
             document_size,
             document,
             contract_id
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  type_id = :O_usage_curr;
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

/* The cursor for read from database test-information      */
EXEC SQL AT  :O_db_name
    DECLARE  Ctest_cursor CURSOR FOR
     SELECT  to_char(A.date_created, 'DD-MM-YYYY'),
             A.type_id,
             B.type_shdes,
             COUNT(*)
       FROM  document_all A,
             doc_types    B
      WHERE  A.type_id = B.type_id
   GROUP BY  A.date_created, A.type_id, B.type_shdes
   ORDER BY  A.date_created, A.type_id, B.type_shdes;

/* The next three statements are not mandatory because       */
/* they are the default                                      */
EXEC SQL WHENEVER SQLERROR   CONTINUE;
EXEC SQL WHENEVER NOT FOUND  CONTINUE;
EXEC SQL WHENEVER SQLWARNING CONTINUE;

/* The new cursor for BSCS4 database */

/* The cursor for read invoice from_database                 */
EXEC SQL AT  :O_db_name
    DECLARE  Cnewmain_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             customer_id,
             contract_id,
             bgh_process,
             document_size,
             document,
             bill_ins_code,
             cslevel
       FROM  document_all
      WHERE  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
   ORDER BY  sort_criteria,customer_id;

/* The cursor for read a single-customer invoice from_database */
EXEC SQL AT  :O_db_name
    DECLARE  Cnewsingle_main_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document,
             bill_ins_code,
             cslevel
       FROM  document_all
      WHERE  customer_id= :O_customer_id
        AND  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
   ORDER BY  sort_criteria;

/* The cursor for read from database invoice-dependent documents */

EXEC SQL AT  :O_db_name
    DECLARE  Cnewsecond_cursor CURSOR FOR
     SELECT  rowid,
             contract_id,
             document_size,
             document,
             bill_ins_code
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  bgh_process = :O_unique_id
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

EXEC SQL AT  :O_db_name
    DECLARE  Cnewsecond_common_cursor CURSOR FOR
     SELECT  rowid,
             contract_id,
             document_size,
             document,
             bill_ins_code
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  type_id = :O_usage_curr
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/
#else

/* The cursor for read invoice from_database                 */
EXEC SQL AT  :O_db_name
    DECLARE  Cmain_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             customer_id,
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document
       FROM  document_all
      WHERE  type_id = :O_usage_prim 
        AND  bgh_process = :O_BghId
        AND  processed_by_bgh IS null
   ORDER BY  sort_criteria;

/* The cursor for read a single-customer invoice from_database */
EXEC SQL AT  :O_db_name
    DECLARE  Csingle_main_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document
       FROM  document_all
      WHERE  customer_id= :O_customer_id
        AND  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
        AND  processed_by_bgh IS null
   ORDER BY  sort_criteria;

/* The cursor for read from database invoice-dependent documents */

EXEC SQL AT  :O_db_name
    DECLARE  Csecond_cursor CURSOR FOR
     SELECT  rowid,
             document_size,
             document,
             contract_id
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  bgh_process = :O_unique_id
        AND  processed_by_bgh IS null
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

EXEC SQL AT  :O_db_name
    DECLARE  Csecond_common_cursor CURSOR FOR
     SELECT  rowid,
             document_size,
             document,
             contract_id
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  type_id = :O_usage_curr
        AND  processed_by_bgh IS null
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

/* The cursor for read from database test-information      */
EXEC SQL AT  :O_db_name
    DECLARE  Ctest_cursor CURSOR FOR
     SELECT  to_char(A.date_created, 'DD-MM-YYYY'),
             A.type_id,
             B.type_shdes,
             COUNT(*)
       FROM  document_all A,
             doc_types    B
      WHERE  A.type_id = B.type_id
        AND  A.processed_by_bgh IS null
   GROUP BY  A.date_created, A.type_id, B.type_shdes
   ORDER BY  A.date_created, A.type_id, B.type_shdes;

/* The next three statements are not mandatory because       */
/* they are the default                                      */
EXEC SQL WHENEVER SQLERROR   CONTINUE;
EXEC SQL WHENEVER NOT FOUND  CONTINUE;
EXEC SQL WHENEVER SQLWARNING CONTINUE;

/* The new cursor for BSCS4 database */

/* The cursor for read invoice from_database                 */
EXEC SQL AT  :O_db_name
    DECLARE  Cnewmain_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             customer_id,
             contract_id,
             bgh_process,
             document_size,
             document,
             bill_ins_code,
             cslevel
       FROM  document_all
      WHERE  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
        AND  processed_by_bgh IS null
   ORDER BY  sort_criteria,customer_id;

/* The cursor for read a single-customer invoice from_database */
EXEC SQL AT  :O_db_name
    DECLARE  Cnewsingle_main_cursor CURSOR FOR
     SELECT  rowid,
             contr_group,
             to_char(date_created, 'DD-MM-YYYY'),
             ohxact,
             contract_id,
             bgh_process,
             document_size,
             document,
             bill_ins_code,
             cslevel
       FROM  document_all
      WHERE  customer_id= :O_customer_id
        AND  type_id = :O_usage_prim
        AND  bgh_process = :O_BghId
        AND  processed_by_bgh IS null
   ORDER BY  sort_criteria;

/* The cursor for read from database invoice-dependent documents */

EXEC SQL AT  :O_db_name
    DECLARE  Cnewsecond_cursor CURSOR FOR
     SELECT  rowid,
             contract_id,
             document_size,
             document,
             bill_ins_code
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  bgh_process = :O_unique_id
        AND  processed_by_bgh IS null
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

EXEC SQL AT  :O_db_name
    DECLARE  Cnewsecond_common_cursor CURSOR FOR
     SELECT  rowid,
             contract_id,
             document_size,
             document,
             bill_ins_code
       FROM  document_all
      WHERE  customer_id = :O_customer_id
        AND  type_id = :O_usage_curr
        AND  processed_by_bgh IS null
        AND  to_char(date_created, 'DD-MM-YYYY') = :O_date_created;
/**/

#endif

/* The cursor for BSCS4 specific tables */

/* Cursor for access to 'DOC_TYPES' */
EXEC SQL AT  :O_db_name
    DECLARE  Cdoc_type CURSOR FOR
     SELECT  type_id,
             gen_this_msg
       FROM  doc_types
   ORDER BY  type_id;

/* Cursor for access to 'IMG_TYPES' */
EXEC SQL AT  :O_db_name
    DECLARE  Cimg_type CURSOR FOR
     SELECT  type_id,
             shdes,
             default_copies
       FROM  img_types
   ORDER BY  type_id;

/* Cursor for access to 'IMG_TYPES_LEVEL' */
EXEC SQL AT  :O_db_name
    DECLARE  Cimg_type_level CURSOR FOR
     SELECT  type_id,
             cslevel
       FROM  img_types_level
   ORDER BY  type_id;

/* Cursor for access to 'IMG_LNK_DOC' */
EXEC SQL AT  :O_db_name
    DECLARE  Cimg_lnk CURSOR FOR
     SELECT  doc_type_id,
             img_type_id
       FROM  img_lnk_doc
   ORDER BY  doc_type_id;

/* Cursor for access to 'CUST_IMAGES' */
EXEC SQL AT  :O_db_name
    DECLARE  Ccust_img CURSOR FOR
     SELECT  customer_id,
             type_id,
             copies
       FROM  cust_images
   ORDER BY  customer_id;

/* Cursor for access to 'MPDPLTAB' */
EXEC SQL AT  :O_db_name
    DECLARE  Cvplmn CURSOR FOR
     SELECT  shdes,
             plmnname, 
             country
       FROM  mpdpltab
   ORDER BY  shdes;


EXEC SQL AT  :O_db_name
    DECLARE  Ctzone CURSOR FOR
     SELECT  zncode,
             des, 
             shdes
       FROM  mpuzntab
   ORDER BY  shdes;

EXEC SQL AT  :O_db_name
    DECLARE  Cttime CURSOR FOR
     SELECT  ttcode,
             des, 
             shdes
       FROM  mputttab
   ORDER BY  shdes;

EXEC SQL AT  :O_db_name
    DECLARE  Csname CURSOR FOR
     SELECT  SNCODE,
             DES,
             SHDES
       FROM  MPUSNTAB
   ORDER BY  SHDES;


EXEC SQL AT  :O_db_name
    DECLARE  Ctmodel CURSOR FOR
     SELECT  TMCODE,
             VSCODE,
             DES,
             SHDES
       FROM  MPUTMTAB
      WHERE  STATUS = 'P'
   ORDER BY  SHDES;

EXEC SQL AT  :O_db_name
    DECLARE  Cspackage CURSOR FOR
     SELECT  SPCODE,
             DES,
             SHDES
       FROM  MPUSPTAB
   ORDER BY  SHDES;

EXEC SQL AT  :O_db_name
    DECLARE  Cpn CURSOR FOR
     SELECT  ZP.DIGITS
       FROM  MPUPNTAB PN, MPUZPTAB ZP
      WHERE  PN.ZPCODE = ZP.ZPCODE
   ORDER BY  ZP.DIGITS;

EXEC SQL AT  :O_db_name
    DECLARE  Ccust_sim_list CURSOR FOR
      SELECT CA.CUSTCODE CUSTCODE,
             CC.CCFNAME,
             CC.CCLNAME,
             CN.CO_ID,
             TO_CHAR(CN.CO_ACTIVATED, 'yymmdd'),
             SM.SUBM_SHDES, 
             SM.SUBM_DES,
             DN.DN_NUM,
             CD.CD_SM_NUM
        FROM SUB_MARKET SM,
             CUSTOMER_ALL CA,
             CCONTACT_ALL CC,
             CONTRACT_ALL CN,
             CONTR_DEVICES CD,
             CONTR_SERVICES_CAP CSP,
             DIRECTORY_NUMBER DN
       WHERE SM.SUBM_ID = CN.SUBM_ID 
         AND CA.CUSTOMER_ID = CC.CUSTOMER_ID 
         AND CA.CUSTOMER_ID = CN.CUSTOMER_ID 
         AND CN.CO_ID = CD.CO_ID 
         AND CSP.CO_ID = CN.CO_ID 
         AND CSP.DN_ID = DN.DN_ID
         AND CC.CCBILL = 'X'
         AND CA.CUSTOMER_ID = :O_sim_customer_id
    ORDER BY CN.CO_ID;

EXEC SQL AT  :O_db_name
     DECLARE Csub_cust_list CURSOR FOR
      SELECT CUSTOMER_ID
        FROM CUSTOMER_ALL
       WHERE CUSTOMER_ID_HIGH = :O_sim_customer_id;

/*  The cursor for WorkParVal */

EXEC SQL AT :O_db_name
DECLARE CWParVal_cursor CURSOR FOR
SELECT 
    TO_CHAR(a.WPARCODE,'FM9999999999999999999999'), 
    TO_CHAR(CUSTOMER_ID,'FM9999999999999999999999'), 
    TO_CHAR(CO_ID,'FM9999999999999999999999'),
    WPARVAL,
    TO_CHAR(FINISH_DATE,'YYYYMMDD'),
    FIELD1,
    FIELD2,
    FIELD3,
    FIELD4,
    FIELD5 
FROM 
    RIH_WORKPARVAL a,
    EDS_BGH_WPARCODE b
WHERE  
    :O_WParValDate = TO_CHAR(a.FINISH_DATE, 'YYYYMMDD')  AND
    a.WPARCODE = b.WPARCODE
ORDER BY a.WPARCODE;


/*************************************************************/
/* Other external variables                                  */
/*************************************************************/
extern stBGHGLOB stBgh;
extern stVPLMN *pstVPLMN;
#ifdef BSCS4
extern stDOCTYPES	*pstDocTypes;		/* pointer to array of structures */
extern stIMGTYPES	*pstImgTypes;		/* pointer to array of structures */
extern stIMGTYPESLV	*pstImgTypLevel;       	/* pointer to array of structures */
extern stIMGLNKDOC	*pstImgLnk;		/* pointer to array of structures */
extern stCUSTIMAGES	*pstCustImg;		/* pointer to array of structures */
#endif

/*************************************************************/
/* Other global variables                                    */
/*************************************************************/

static char message[MAX_BUF];
BOOL connected     = FALSE;	/* stores status of database      */
BOOL status_single = FALSE;     /* status for a single customer   */
long current_customer_id;
long current_contract_id;
char current_date_created[15];
char **rowid_array; /* pointer to a array of rowid's for  */
                    /* a customer-related documents       */
int n_of_elem;      /* number of rowid-stack elements     */

static long itb_contract_id; /* contract to which a itemized-bill */
                             /* is associated.                    */
static int  count_attempt;   /* stores number of rollback-attempts */

/*************************************************************/
/* External functions                                        */
/*************************************************************/
extern sqlglm (char *, size_t *, size_t *);

/*************************************************************/
/* Prototypes of functions used in this file                 */
/*************************************************************/

void sqlerror(int code, char *occurrence);
int  ReadAgainFromDatabase(TYPEID timm_type);
int  foiHandleTestCursor(HANDLE handle);
int  foiPutOnStack (BOOL);
int  foiMarkCustomer(char *);
int  MarkProcessed(char *);
void FreeStack(void);

static int fnCloseBalanceCursor( TYPEID   usage_type);
static int fnGetNumberOfCustomers(TYPEID enDocType, long *pplNumberOfCustomers);



/*************************************************************/
/* PrintVersInfoBghEsql                                      */
/*                                                           */
/* DESCRIPTION:                                              */
/* print the version info of all BGH_ESQL                    */
/*                                                           */
/* PARAMETERS:                                               */
/*  void                                                     */
/*                                                           */
/* RETURNS:                                                  */
/*  - none -                                                 */
/*                                                           */
/*************************************************************/

void PrintVerInfoBghEsql (void)
{
  static char *SCCS_VERSION = "1.42";

  printf ("%s\t\t\t%s\n", __FILE__, SCCS_VERSION);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : closes the balance cursor                      */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_CLOSEBALANCECURSOR : close second cursor              */
/*                                                           */
/*************************************************************/

static int fnCloseBalanceCursor( TYPEID   usage_type)  /* ITB, SUM, ROA, LGN, BAL for second cursor */
{
  int rc;
  
  rc = 0;
  
  EXEC SQL CLOSE  Cbalance_cursor;
  if (sqlca.sqlcode != 0)
    {
      rc = ESQL_CLOSEBALANCECURSOR;
      sprintf(message, "foiHandleCursor: Could not close balance cursor ");
      sqlerror(rc, message);
    }
  else
    {
      fovdPrintLog (LOG_DEBUG, "Closed Cursor: Cbalance_cursor, with usage_type: %d\n", usage_type);
    }
  return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : opens the balance cursor                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor                                          */
/*							     */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_OPENBALANCECURSOR  : open balance cursor             */
/*                                                           */
/*************************************************************/

static int fnOpenBalanceCursor( TYPEID   usage_type)
{
   int rc;

   rc = 0;
   O_usage_prim = usage_type;
   O_usage_lgn_type = LGN_TYPE;
   
   fovdPrintLog (LOG_DEBUG,
                 "Open Balance Cursor DOCUMENT_ALL in '%s' with:\n"
                 "     TYPE_ID     = <%d>\n"
                 " And TYPE_ID     = <%d>\n", O_db_name.arr,
                 usage_type,LGN_TYPE);
   
   EXEC SQL OPEN Cbalance_cursor;
   
   if (sqlca.sqlcode != 0)
     {
       rc = ESQL_OPENBALANCECURSOR;
       sprintf(message, "foiHandleCursor: Could not open balance cursor ");
       sqlerror(rc, message);
     }
   else
     {
       fovdPrintLog(LOG_DEBUG, "Opened Cursor: Cbalance_cursor, with usage_type: %d and: %d\n", usage_type,LGN_TYPE);
     }

   return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT :  get the number of Customers to be processed   */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_UPDATE          :                                    */
/*                                                           */
/*************************************************************/

static int fnGetNumberOfCustomers(TYPEID enDocType, long *pplNumberOfCustomers)
{
  int rc = 0;

  O_usage_prim = enDocType;
  O_usage_lgn_type = LGN_TYPE;
  
  EXEC SQL AT  :O_db_name
    SELECT  count(*)
    INTO  :O_NumberOfCustomers
    FROM  document_all
    WHERE  type_id in (:O_usage_prim)
    AND  processed_by_bgh IS null;
  
  
  if (sqlca.sqlcode != 0)
    {
      /* if != NO_MORE_DATA */
      if (sqlca.sqlcode != 1403) 
        {
          rc = ESQL_SELECT;
          sprintf(message, "%s%s\n",
                  "Select from document_all count(*) in module failed:",
                  "ballance");
          sqlerror(rc, message);     
        } 
      else 
        { 
          *pplNumberOfCustomers = 0L;
          rc = ESQL_NOMOREDATA;
        }
    } 
  else 
    {
      if(O_NumberOfCustomers == 0) 
        {
          *pplNumberOfCustomers = 0L;
          rc = ESQL_NOMOREDATA;
        } 
      else 
        {
          *pplNumberOfCustomers = O_NumberOfCustomers;
          fovdPrintLog (LOG_NORMAL,"Ballance: found %ld customers to process\n", *pplNumberOfCustomers);
        }
    }
  
  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT :  assign the customers to one of the parallel   */
/*             running BGHs                                  */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_UPDATE          :                                    */
/*                                                           */
/*************************************************************/

int fnBalanceData(TYPEID enDocType, long polNumberOfProcesses)
{
  int rc;
  int count;
  int ret;
  long lolNumberOfCustomers;
  long lolNumberPerProcess;

  count = 0;
  rc = 0;

  fovdPrintLog (LOG_DEBUG, "Trying to get number of customers to process!\n");
  printf ("Getting number of customers to process:\n");

  rc = fnGetNumberOfCustomers(enDocType,&lolNumberOfCustomers);
  lolNumberPerProcess = (lolNumberOfCustomers / polNumberOfProcesses) + 1;

  if (rc == 0) 
    {
      printf ("    %ld, %ld per process\n", lolNumberOfCustomers, lolNumberPerProcess);
      fovdPrintLog (LOG_NORMAL,
                    "Number of customers:             %ld\n"
                    "Number of customers per process: %ld\n",
                    lolNumberOfCustomers, lolNumberPerProcess);
      
      rc = fnOpenBalanceCursor(enDocType);
    }
  
  if ( rc == 0) 
    {
      printf ("Assinging customers to processes.");      
      while (rc == 0) 
        {
          EXEC SQL FETCH Cbalance_cursor INTO :O_customer_id;
          if(sqlca.sqlcode != 0) 
            {
              if(sqlca.sqlcode != SQL_NODATAFOUND) 
                {
                  rc = ESQL_FETCHCURSOR;
                  sprintf (message, "Balance Cursor: SQL-Error, usage: %d", enDocType);
                  sqlerror (rc, message);
                }
              else /* no more data */ 
                {
                  rc = ESQL_NOMOREDATA;
                  fovdPrintLog (LOG_DEBUG, "mDatabase: no more data\n");
                } /* end no more data */
            } 
          else 
            { /* if(sqlca.sqlcode != 0) */
              O_BghId = count / lolNumberPerProcess;  

              EXEC SQL AT  :O_db_name
                UPDATE  document_all 
                SET   bgh_process = :O_BghId
                WHERE   current of Cbalance_cursor;

              if (sqlca.sqlcode != 0)
                {
                  /* if != NO_MORE_DATA */
                  if (sqlca.sqlcode != 1403) 
                    {
                      rc = ESQL_UPDATE;
                      sprintf(message, "%s%s\n", "Updating document_all, balance as processed failed in module: balance");
                      sqlerror(rc, message);     
                    } 
                  else 
                    { 
                      rc = ESQL_NOMOREDATA;
                      fovdPrintLog (LOG_NORMAL,"Ballance: Nothing to process\n");
                      fprintf(stdout, "Nothing to process\n");
                    }
                } 
              else 
                {
                  /* update worked */
                  /* increase the number of customers to be processed */

                  count ++;

                  /*
                  count = count + sqlca.sqlerrd[2];
                  */
                }
              
              if (enDocType == INV_TYPE)
                {
                  /*
                   * Sign one BAL message
                   */

                  EXEC SQL AT :O_db_name FOR 1
                    UPDATE document_all 
                    SET bgh_process = :O_BghId
                    WHERE customer_id = :O_customer_id
                    AND type_id = 0
                    AND processed_by_bgh is null;

                  if (sqlca.sqlcode != 0)
                    {
                      /* if != NO_MORE_DATA */
                      if (sqlca.sqlcode != 1403) 
                        {
                          rc = ESQL_UPDATE;
                          sprintf(message, "%s%s\n", "Updating document_all, balance for BAL as processed failed in module: balance");
                          sqlerror(rc, message);     
                        } 
                    }

                  /*
                   * Sign one SUM message
                   */
                  
                  EXEC SQL AT :O_db_name FOR 1
                    UPDATE document_all 
                    SET bgh_process = :O_BghId
                    WHERE customer_id = :O_customer_id
                    AND type_id = 3
                    AND processed_by_bgh is null;
                  
                  if (sqlca.sqlcode != 0)
                    {
                      /* if != NO_MORE_DATA */
                      if (sqlca.sqlcode != 1403) 
                        {
                          rc = ESQL_UPDATE;
                          sprintf(message, "%s%s\n", "Updating document_all, balance for SUM as processed failed in module: balance");
                          sqlerror(rc, message);     
                        } 
                    }

                  /*
                   * Sign one ROA message
                   */

                  EXEC SQL AT :O_db_name FOR 1
                    UPDATE document_all 
                    SET bgh_process = :O_BghId
                    WHERE customer_id = :O_customer_id
                    AND type_id = 4
                    AND processed_by_bgh is null;

                  if (sqlca.sqlcode != 0)
                    {
                      /* if != NO_MORE_DATA */
                      if (sqlca.sqlcode != 1403) 
                        {
                          rc = ESQL_UPDATE;
                          sprintf(message, "%s%s\n", "Updating document_all, balance for ROA as processed failed in module: balance");
                          sqlerror(rc, message);     
                        } 
                    }

                  /*
                   * Sign all DNL messages if speficied 
                   */

                  if (stBgh.bDunningGen == TRUE)
                    {
                      EXEC SQL AT :O_db_name FOR 1
                        UPDATE document_all 
                        SET bgh_process = :O_BghId
                        WHERE customer_id = :O_customer_id
                        AND type_id = 8
                        AND processed_by_bgh is null;

                      if (sqlca.sqlcode != 0)
                        {
                          /* if != NO_MORE_DATA */
                          if (sqlca.sqlcode != 1403) 
                            {
                              rc = ESQL_UPDATE;
                              sprintf(message, "%s%s\n", "Updating document_all, balance for DNL as processed failed in module: balance");
                              sqlerror(rc, message);     
                            } 
                        }
                    }

                  /*
                   * Sign all WLL messages if specified 
                   */

                  if (stBgh.bWelcomeGen == TRUE) 
                    {
                      EXEC SQL AT :O_db_name FOR 1
                        UPDATE document_all 
                        SET bgh_process = :O_BghId
                        WHERE customer_id = :O_customer_id
                        AND type_id = 9
                        AND processed_by_bgh is null;

                      if (sqlca.sqlcode != 0)
                        {
                          /* if != NO_MORE_DATA */
                          if (sqlca.sqlcode != 1403) 
                            {
                              rc = ESQL_UPDATE;
                              sprintf(message, "%s%s\n", "Updating document_all, balance for WLL as processed failed in module: balance");
                              sqlerror(rc, message);     
                            } 
                        }
                    }
                  
                  /*
                   * Sign all INP messages if specified
                   */

                  if (stBgh.bINPGen == TRUE) 
                    {
                      EXEC SQL AT :O_db_name FOR 1
                        UPDATE document_all 
                        SET bgh_process = :O_BghId
                        WHERE customer_id = :O_customer_id
                        AND type_id = 12
                        AND processed_by_bgh is null;

                      if (sqlca.sqlcode != 0)
                        {
                          /* if != NO_MORE_DATA */
                          if (sqlca.sqlcode != 1403) 
                            {
                              rc = ESQL_UPDATE;
                              sprintf(message, "%s%s\n", "Updating document_all, balance for INP as processed failed in module: balance");
                              sqlerror(rc, message);     
                            } 
                        }
                    }

                  /*
                   * Sign all INL messages if specified
                   */

                  if (stBgh.bINLGen == TRUE) 
                    {
                      EXEC SQL AT :O_db_name FOR 1
                        UPDATE document_all 
                        SET bgh_process = :O_BghId
                        WHERE customer_id = :O_customer_id
                        AND type_id = 13
                        AND processed_by_bgh is null;

                      if (sqlca.sqlcode != 0)
                        {
                          /* if != NO_MORE_DATA */
                          if (sqlca.sqlcode != 1403) 
                            {
                              rc = ESQL_UPDATE;
                              sprintf(message, "%s%s\n", "Updating document_all, balance for INL as processed failed in module: balance");
                              sqlerror(rc, message);     
                            } 
                        }
                    }

                  /*
                   * all misc. messages signed 
                   */
                }
            }
          /* else if(sqlca.sqlcode != 0) */
          
          printf ("\rAssinged %d customers to processes.", count);
        } 
      /* While */

      printf ("\n");
      
      if (rc == ESQL_NOMOREDATA)
        {
          rc = 0;
        }   
    }   
  
  if(rc == 0) 
    {        
      ret = fnCloseBalanceCursor(enDocType);
      if (ret != 0) 
        {
          rc = ret;
        }
    }
  
  if(rc == 0) 
    {
      fovdPrintLog (LOG_NORMAL,"balance: Updated document_all, updated %d record(s) \n", count);
      fprintf(stdout, "balance marked %d record(s) \n", count);
      rc = foiCommitWork();
    }
  return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading test-data from document_all and        */
/*            doc_types with cursor                          */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading test-data from the database-tables                */
/* document_all and doc_types with a cursor.                 */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_FETCHTESTCURSOR : fetching                           */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/

int GetTestFromDatabase(void)
{
   int rc;
   int ret;

   rc  = 0;
   ret = 0;
   T_count = 0;

   fovdPrintLog (LOG_DEBUG, "Trying to run a database test\n");

   rc = foiHandleTestCursor(sql_open);
   if (rc == 0)
   {
     sprintf (message,
	      "Printing database-information: count, type_id, type_shdes, date_created\n");
     fovdPrintLog (LOG_NORMAL, message);
     fprintf(stdout, "%s", message);

     while (rc == 0)
     {
       EXEC SQL FETCH Ctest_cursor INTO
                      :T_date_created,
                      :T_type_id,
                      :T_type_shdes,
                      :T_count;

       if(sqlca.sqlcode != 0)
       {
         if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_FETCHTESTCURSOR;
           count_attempt = 0;
           sprintf(message, "GetTestFromDatabase: SQL-Error");
           sqlerror(rc, message);
           ret = foiHandleTestCursor(sql_close);
           if( ret != 0)
           {
             rc = ret;
           }
         }
         else /* no more data */
         {
           rc = ESQL_NOMOREDATA;
           ret = foiHandleTestCursor(sql_close);
           if( ret != 0)
           {
             rc = ret;
           }
         } /* end if sqlca.sqlcode .... */
       } /* end if sqlca.sqlcode != 0 */

       if (rc == 0)
       {
         STRCPY_FROM_ORA (t_date_created, T_date_created);
         STRCPY_FROM_ORA (t_type_shdes, T_type_shdes);
         sprintf (message,
		  "%8d %3d %-6s %-15s\n", T_count, T_type_id, t_type_shdes, t_date_created);
         fovdPrintLog (LOG_NORMAL, message);
         fprintf (stdout, "%s", message);
       }
     } /* end while */
   } /*end if */

   return (rc);
} /* end GetTestFromDatabase subroutine */


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading version check permision of batch-      */
/*            modules from table bscsproject_all             */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading if the version check is enabled for batch-modules */
/* from the database-table bscsproject_all.                  */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_CHECKBATCH      : selecting version-check            */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/

int GetCheckBatchFromDatabase(BOOL *checkbatch_enabled)
{
   int rc;
   rc  = 0;

   fovdPrintLog (LOG_DEBUG,
		 "Trying to get if version check is enabled for batch-modules\n");

   EXEC SQL AT  :O_db_name
        SELECT  vcheck_b
          INTO  :V_vcheck_b
          FROM  bscsproject_all;

   if(sqlca.sqlcode != 0)
   {
     if(sqlca.sqlcode != SQL_NODATAFOUND)
     {
       rc = ESQL_CHECKBATCH;
       count_attempt = 0;
       sprintf(message, "GetCheckBatchFromDatabase: SQL-Error");
       sqlerror(rc, message);
     }
     else /* no data */
     {
       rc = ESQL_NOMOREDATA;
       count_attempt = 0;
       sprintf(message, "GetCheckBatchFromDatabase: Version check in table bscsproject_all not found");
       sqlerror(rc, message);
     } /* end if sqlca.sqlcode .... */
   } /* end if sqlca.sqlcode != 0 */

   if (rc == 0)
   {

     fovdPrintLog (LOG_DEBUG,
		   "GetCheckBatchFromDatabase: Version check is successfully read.\n");

     if (V_vcheck_b.arr[0] == STATUS_ENABLED)
     {
       *checkbatch_enabled = TRUE;
       fovdPrintLog (LOG_DEBUG,
		     "GetCheckBatchFromDatabase: Version check is enabled\n");
     }
     else
     {
       *checkbatch_enabled = FALSE;
       fovdPrintLog (LOG_DEBUG,
		     "GetCheckBatchFromDatabase: Version check is disabled\n");
     }

   }

   return (rc);

} /* end GetCheckBatchFromDatabase subroutine */


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading version number of BGH from table       */
/*            app_modules                                    */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading the version-number of the modul-BGH from          */
/* the database-table app_modules.                           */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELVERS         : selecting version-number           */
/* ESQL_NOMOREDATA      : no more data                       */
/* ESQL_ALLOC           : malloc for version-number          */
/*                                                           */
/*************************************************************/

int GetVersionFromDatabase(char **version_string)
{
   int rc;
   int ret;
   char *alloc_string;

   rc  = 0;
   ret = 0;
   alloc_string = NULL;

   fovdPrintLog (LOG_DEBUG, "Trying to get BGH-version-number\n");

   STRCPY_TO_ORA(V_modulename, MODULE_BGH);

   EXEC SQL AT  :O_db_name
        SELECT  version
          INTO  :V_version INDICATOR :V_version_ind
          FROM  app_modules
         WHERE  modulename = :V_modulename;

   if(sqlca.sqlcode != 0)
   {
     if(sqlca.sqlcode != SQL_NODATAFOUND)
     {
       rc = ESQL_SELVERS;
       count_attempt = 0;
       sprintf(message, "GetVersionFromDatabase: SQL-Error");
       sqlerror(rc, message);
     }
     else /* no data */
     {
       rc = ESQL_NOMOREDATA;
       count_attempt = 0;
       sprintf(message, "GetVersionFromDatabase: Module BGH in table app_modules not found");
       sqlerror(rc, message);
     } /* end if sqlca.sqlcode .... */
   } /* end if sqlca.sqlcode != 0 */

   if (rc == 0)
   {

     alloc_string = (char *)malloc((V_version.len + 1)*sizeof(char));
     if (alloc_string == NULL)
     {
       rc = ESQL_ALLOC;
       count_attempt = 0;
       sprintf(message, "GetVersionFromDatabase: Error by malloc");
       sqlerror(rc, message);
     }
     else
     {
       STRCPY_FROM_ORA(alloc_string, V_version);
       fovdPrintLog (LOG_DEBUG,
		     "GetVersionFromDatabase: Version-number is successfully read.\n");
     } /* end if alloc... */
   } /* end if rc...  */

   *version_string = alloc_string;

   return (rc);
} /* end GetVersionFromDatabase subroutine */

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading base directory of BGH from table       */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading the base directory of the modul-BGH from          */
/* the database-table mpscftab.                              */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELBASEDIR      : selecting base-directory           */
/* ESQL_NULLBASEDIR     : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/
int GetBaseDirectoryFromDatabase(void)
{
   int rc;

   rc  = 0;

   fovdPrintLog (LOG_DEBUG, "Trying to get BGH-base-directory\n");

   B_cfcode = BSCS_PATH; /* BSCS_PATH-value is in common.h */

   EXEC SQL AT  :O_db_name
        SELECT  cfvalue
          INTO  :B_cfvalue INDICATOR :B_cfvalue_ind
          FROM  mpscftab
         WHERE  cfcode = :B_cfcode;

   if(sqlca.sqlcode != 0)
   {
     if(sqlca.sqlcode != SQL_NODATAFOUND)
     {
       rc = ESQL_SELBASEDIR;
       count_attempt = 0;
       sprintf(message, "GetBaseDirectoryFromDatabase: SQL-Error");
       sqlerror(rc, message);
     }
     else /* no data */
     {
       rc = ESQL_NOMOREDATA;
       count_attempt = 0;
       sprintf(message, "GetBaseDirectoryFromDatabase: base directory info in table mpscftab not found");
       sqlerror(rc, message);
     } /* end if sqlca.sqlcode .... */
   } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
   {
     if( B_cfvalue_ind < 0)
       {
         rc = ESQL_NULLBASEDIR;
         fovdPrintLog (LOG_NORMAL, "GetBaseDirectoryFromDatabase: NULL in database for base-directory detected\n");
       }
     else
       {
         STRCPY_FROM_ORA(stBgh.szBaseDirectory, B_cfvalue); /* base_directory is member of the global */
         /* structure stBGHGLOB                    */
         fovdPrintLog (LOG_DEBUG, "GetBaseDirectoryFromDatabase: base directory [%s] is successfully read.\n", stBgh.szBaseDirectory);
       }
   }

   return (rc);

} /* end GetBaseDirectoryFromDatabase subroutine */

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading bill-images-process-program from table */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading the bill-images-process-programm from             */
/* the database-table mpscftab.                              */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELPROCPROG     : selecting process-program          */
/* ESQL_NULLPROCPROG    : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/

int GetProcessProgramFromDatabase(void)
{
   int rc;

   rc  = 0;
   
   /*
    * BI_IMAGE_PROCESS_CFVAL
    */
   
   fovdPrintLog (LOG_DEBUG, "Trying to get bill-images-process-program\n");
   
   PP_cfcode = BI_IMAGE_PROCESS_CFVAL;
   
   EXEC SQL AT  :O_db_name
        SELECT  cfvalue
          INTO  :PP_cfvalue INDICATOR :PP_cfvalue_ind
          FROM  mpscftab
         WHERE  cfcode = :PP_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELPROCPROG;
           count_attempt = 0;
           sprintf(message, "GetProcessProgramFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           /* no error message, because the calling program writes one */
#if 0
           sprintf(message, 
                   "GetProcessProgramFromDatabase: bill-images-process-program info in table mpscftab not found");
           sqlerror(rc, message);
#endif
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if( PP_cfvalue_ind < 0)
         {
           rc = ESQL_NULLPROCPROG;
           /* no error message, because the calling program writes one */
#if 0
           fovdPrintLog (LOG_NORMAL,
                         "GetProcessProgramFromDatabase: NULL in database for base-directory detected\n");
#endif
         }
       else
         {
           STRCPY_FROM_ORA(stBgh.szBIProcessProgram, PP_cfvalue); 
           /* bill-images-process-program is member of the global */
           /* structure stBGHGLOB                    */
           fovdPrintLog (LOG_DEBUG, 
                         "GetProcessProgramFromDatabase: Image proc: %s\n", stBgh.szBIProcessProgram);
         }
     }
   
   /*
    * BIZ_IMAGE_PROCESS_CFVAL
    */

#ifdef _COMPRESS_IMAGE_
   
   fovdPrintLog (LOG_DEBUG, "Trying to get zipped-bill-images-process-program\n");
   
   PP_cfcode = BIZ_IMAGE_PROCESS_CFVAL;

   EXEC SQL AT  :O_db_name
        SELECT  cfvalue
          INTO  :PP_cfvalue INDICATOR :PP_cfvalue_ind
          FROM  mpscftab
         WHERE  cfcode = :PP_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELPROCPROG;
           count_attempt = 0;
           sprintf(message, "GetProcessProgramFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           /* no error message, because the calling program writes one */
#if 0
           sprintf(message, 
                   "GetProcessProgramFromDatabase: bill-images-process-program info in table mpscftab not found");
           sqlerror(rc, message);
#endif
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if( PP_cfvalue_ind < 0)
         {
           rc = ESQL_NULLPROCPROG;
           /* no error message, because the calling program writes one */
#if 0
           fovdPrintLog (LOG_NORMAL,
                         "GetProcessProgramFromDatabase: NULL in database for base-directory detected\n");
#endif
         }
       else
         {
           STRCPY_FROM_ORA(stBgh.szBIZProcessProgram, PP_cfvalue); 
           /* bill-images-process-program is member of the global */
           /* structure stBGHGLOB                    */
           fovdPrintLog (LOG_DEBUG, 
                         "GetProcessProgramFromDatabase: Image proc: %s\n", stBgh.szBIZProcessProgram);
         }
     }

#endif
   
   return (rc);
   
} /* end GetProcessProgramFromDatabase subroutine */



/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading data from document_all with cursor     */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading from the database with a cursor. O_usage is       */
/* either an Invoice or an Itemized-bill.                    */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*   ReadAgainFromDatabase()                                 */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0              : The function worked properly           */
/*   ERRORS                                                  */
/* ESQL_ALLOC       : alloc                                  */
/* ESQL_FETCHCURSOR : fetching                               */
/* ESQL_NOMOREDATA  : no more data                           */
/* ESQL_DOCSIZENULL : document_size is zero                  */
/*                                                           */
/*************************************************************/
int GetTimmFromSecondaryCursor (char  **string_to_parse, /* address of pointer to BLOB-string */
                                int    *string_to_parse_len,
                                void  **string_to_free,  /* address of pointer to memory-block */
                                TYPEID  timm_type,       /* i.e. INV_TYPE */
                                BOOL   *end_indicator,   /* no more data */
                                stDBCOL *stCol) 	  /* for database columns */
{
  int rc;
  int ret;

  rc  = 0;
  ret = 0;
  *end_indicator = FALSE;
  
  /* Allocating memory for the VARCHAR buffer which is used    */
  /* to read the documents from the database.                  */
  O_document = (tLONGVARCHARPTR) malloc (DEFAULT_BLOB_SIZE + sizeof (tLONGVARCHAR) + 1);
  O_document->len = DEFAULT_BLOB_SIZE;
  *string_to_free = (void *)O_document;
  if (NULL == O_document)
    {
      rc = ESQL_ALLOC;
      sprintf(message, "GetTimmFromDatabase: Could not allocate memory for BLOB");
      macErrorMessage(rc, CRITICAL, message);
      *string_to_free = NULL;
      *string_to_parse = NULL;
      *string_to_parse_len = 0;
    }
  
  if (rc == 0) 
    {
      fovdPrintLog (LOG_DEBUG, 
		    "Trying to fetch TIMM-type %d (secondary), buffersize: %d\n", 
		    timm_type, 
		    DEFAULT_BLOB_SIZE);
    }
  
  if (rc == 0)
    {
      EXEC SQL FETCH Cnewsecond_common_cursor INTO
	:O_rowid_curr,
	:O_contract_id INDICATOR :O_contract_id_ind,
	:O_document_size,
	:O_document    INDICATOR :O_document_ind,
	:O_bill_ins_cd INDICATOR :O_bill_ins_ind;
    }
       
  if(sqlca.sqlcode != 0)
    {
      if(sqlca.sqlcode != SQL_NODATAFOUND)
	{
	  rc = ESQL_FETCHCURSOR;
	  count_attempt = 0;
	  sprintf (message, "GetTimmFromDatabase: SQL-Error, usage: %d", timm_type);
	  sqlerror (rc, message);
	}
      else /* no more data */
	{
	  fovdPrintLog (LOG_DEBUG, "GetTimFromDatabase: no data\n");
	  rc = ESQL_NOMOREDATA;
	  *end_indicator = TRUE;
	  free ((void *)O_document);
	  *string_to_free = NULL;
	  *string_to_parse = NULL;
	  *string_to_parse_len = 0;
	  
	} /* end no more data */
    } /* if(sqlca.sqlcode != 0) */
  
  if ((*end_indicator == FALSE) && (rc==0))
    {
      fovdPrintLog (LOG_CUSTOMER,
		    "Read with secondary cursor from DOCUMENT_ALL:\n"
		    "     CUSTOMER_ID  = <%d>\n"
		    "     BGH_PROCESS  = <%d>\n"
		    "     DATE_CREATED = <%.10s>\n"
		    "     DOCUMENT_SIZE= <%d>\n",
		    O_customer_id, O_unique_id, O_date_created.arr, O_document_size);
      fovdPrintLog (LOG_CUSTOMER,
		    "     CSLEVEL      = <%.2s>\n",
		    O_cslevel.arr);

      if(O_document_size + 1 > DEFAULT_BLOB_SIZE) 
        {                                         
	  /* did not read the whole document  */
	  /* try expand the string and reread */
          rc = ReadAgainFromDatabase (timm_type);
        }
      else if (O_document_size == 0)
        {
          rc = ESQL_DOCSIZENULL;
          count_attempt = 0;
          sprintf(message, "GetTimmFromDatabase: %s%s%s%s\n",
                  "ERROR Document_size is ZERO. If this is not an error of ",
                  "the data in the database itself, this may occur  if ",
                  "the *.pc file was not properly compiled. Try to compile ",
                  "the *.pc file again, use compiler option sqlcheck=full");
          sqlerror (rc, message);
        } /* end if O_document_size */
      
      rc = foiPutOnStack (FALSE);      
      if (rc == 0)
        {
          if ((timm_type == ITB_TYPE) && (O_contract_id_ind == 0))
            {
              itb_contract_id = O_contract_id;
            }
          else
            {
              itb_contract_id = 0;
            }
          
          *string_to_free = (void *)O_document;
          *string_to_parse = (char *)O_document->arr;
          *string_to_parse_len = O_document_size;
          (*string_to_parse)[O_document_size] = '\0';
          fovdPrintLog (LOG_DEBUG, "GetTimmFromDatabase: Successfully read document\n");
          
          /* copy additional columns to 'stCol' */          
	  if (O_contract_id_ind == 0) 
	    {
	      stCol->lContId = O_contract_id;
	    } 
	  else 
	    {
	      stCol->lContId = 0;
	    }

	  if (O_cslevel_ind == 0) 
	    {
	      STRCPY_FROM_ORA (stCol->szCsLevel, O_cslevel);
	    } 
	  else 
	    {
	      stCol->szCsLevel[0] = '\0';
	    }
	  
	  if (O_bill_ins_ind == 0) 
	    {
	      STRCPY_FROM_ORA (stCol->szBillIns, O_bill_ins_cd);
	    } 
	  else 
	    {
	      stCol->szBillIns[0] = '\0';
	    }
	}
    }/* if ((*end_indicator == FALSE) && (rc==0))*/
  
  return (rc);    
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading data from document_all with cursor     */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Reading from the database with a cursor. O_usage is       */
/* either an Invoice or an Itemized-bill.                    */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*   ReadAgainFromDatabase()                                 */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0              : The function worked properly           */
/*   ERRORS                                                  */
/* ESQL_ALLOC       : alloc                                  */
/* ESQL_FETCHCURSOR : fetching                               */
/* ESQL_NOMOREDATA  : no more data                           */
/* ESQL_DOCSIZENULL : document_size is zero                  */
/*                                                           */
/*************************************************************/

int GetTimmFromPrimaryCursor (char  **string_to_parse, /* address of pointer to BLOB-string */
                              int    *string_to_parse_len,
                              void  **string_to_free,  /* address of pointer to memory-block */
                              TYPEID  timm_type,       /* i.e. INV_TYPE */
                              BOOL   *end_indicator,   /* no more data */
                              long     customer_id,    /* for single_customer */
                              stDBCOL *stCol) 	  /* for database columns */
{
  int rc;
  int ret;
  
  rc  = 0;
  ret = 0;
  
  *end_indicator = FALSE;

  /* Allocating memory for the VARCHAR buffer which is used    */
  /* to read the documents from the database.                  */
  O_document = (tLONGVARCHARPTR) malloc (DEFAULT_BLOB_SIZE + sizeof (tLONGVARCHAR) + 1);
  O_document->len = DEFAULT_BLOB_SIZE;
  
  *string_to_free = (void *)O_document;
  if (NULL == O_document) 
    {
      rc = ESQL_ALLOC;
      sprintf(message, "GetTimmFromPrimaryCursor: Could not allocate memory for BLOB");
      macErrorMessage(rc, CRITICAL, message);
      *string_to_free = NULL;
      *string_to_parse = NULL;
      *string_to_parse_len = 0;
    }

  if (rc == 0) 
    {  
      /* default memory successfully allocated */
      /* now try to read from database         */	        
      fovdPrintLog (LOG_DEBUG,
		    "Trying to fetch TIMM-type %d (primary), buffersize: %d\n",
		    timm_type, DEFAULT_BLOB_SIZE);
      
      if (status_single == FALSE) /* multiple customers */
	{
	  EXEC SQL FETCH Cnewmain_cursor INTO
	    :O_rowid_inv,
	    :O_contr_group INDICATOR :O_contr_group_ind,
	    :O_date_created,
	    :O_ohxact      INDICATOR :O_ohxact_ind,
	    :O_customer_id,
	    :O_contract_id INDICATOR :O_contract_id_ind,
	    :O_unique_id,
	    :O_document_size,
	    :O_document    INDICATOR :O_document_ind,
	    :O_bill_ins_cd INDICATOR :O_bill_ins_ind,
	    :O_cslevel     INDICATOR :O_cslevel_ind;
	} 
      else
	{
	  EXEC SQL FETCH Cnewsingle_main_cursor INTO
	    :O_rowid_inv,
	    :O_contr_group INDICATOR :O_contr_group_ind,
	    :O_date_created,
	    :O_ohxact      INDICATOR :O_ohxact_ind,
	    :O_contract_id INDICATOR :O_contract_id_ind,
	    :O_unique_id,
	    :O_document_size,
	    :O_document    INDICATOR :O_document_ind,
	    :O_bill_ins_cd INDICATOR :O_bill_ins_ind,
	    :O_cslevel     INDICATOR :O_cslevel_ind;
	}
	      
      fovdPrintLog (LOG_CUSTOMER,
		    "Read with primary cursor from DOCUMENT_ALL:\n"
		    "     CUSTOMER_ID  = <%d>\n"
		    "     BGH_PROCESS  = <%d>\n"
		    "     DATE_CREATED = <%.10s>\n"
		    "     DOCUMENT_SIZE= <%d>\n",
		    O_customer_id, O_unique_id, O_date_created.arr, O_document_size);
      fovdPrintLog (LOG_CUSTOMER,
		    "     CSLEVEL      = <%.2s>\n",
		    O_cslevel.arr);
      
      if(sqlca.sqlcode != 0) 
	{
	  if(sqlca.sqlcode != SQL_NODATAFOUND) 
	    {
	      rc = ESQL_FETCHCURSOR;
	      count_attempt = 0;
	      sprintf (message, "GetTimmFromPrimaryCursor: SQL-Error, usage: %d", timm_type);
	      sqlerror (rc, message);   
	    } 
	  else 
	    { 
	      /* no more data */	      
	      fovdPrintLog (LOG_DEBUG, "GetTimmFromPrimaryCursor: no data\n");	      
	      rc = ESQL_NOMOREDATA;
	      *end_indicator = TRUE;
	      free ((void *)O_document);
	      *string_to_free = NULL;
	      *string_to_parse = NULL;
	      *string_to_parse_len = 0;
	      
	    } /* end no more data */
	} /* if(sqlca.sqlcode != 0) */
    } /* end if (rc == 0) */
      
  if((*end_indicator == FALSE) && (rc ==0)) 
    {
      memcpy (O_rowid_curr.arr, O_rowid_inv.arr, O_rowid_inv.len);
      O_rowid_curr.len = O_rowid_inv.len;
      
      if(O_document_size + 1 > DEFAULT_BLOB_SIZE) 
	{ 
	  /* did not read the whole document  */
	  /* try expand the string and reread */
	  rc = ReadAgainFromDatabase (timm_type);
	} 
      else if (O_document_size == 0) 
	{
	  rc = ESQL_DOCSIZENULL;
	  count_attempt = 0;
	  sprintf(message, "GetTimmFromPrimaryCursor: %s%s%s%s\n",
		  "ERROR Document_size is ZERO. If this is not an error of ",
		  "the data in the database itself, this may occur  if ",
		  "the *.pc file was not properly compiled. Try to compile ",
		  "the *.pc file again, use compiler option sqlcheck=full");
	  sqlerror (rc, message);
	} /* end if O_document_size */      
      
      if (rc==0) 
	{ 
	  /* OK document successfully read */
	  fovdPrintLog (LOG_DEBUG, "GetTimmFromPrimaryCursor: BGH_PROCESS %ld\n", O_write_id);
	  stCol->lCustId = O_customer_id;
	  current_customer_id = O_customer_id;  
	  rc = foiPutOnStack (TRUE);
	}
	  
      if (rc == 0) 
	{
	  if (O_contract_id_ind == 0) 
	    {
	      current_contract_id = O_contract_id;
	    } 
	  else 
	    {
	      current_contract_id = 0;
	    }
	} 
      else 
	{
	  current_contract_id = 0;
	}
      
      STRCPY_FROM_ORA (current_date_created, O_date_created);
      
      if (rc == 0) 
	{
	  if ((timm_type == ITB_TYPE) && (O_contract_id_ind == 0)) 
	    {
	      itb_contract_id = O_contract_id;
	    } 
	  else 
	    {
	      itb_contract_id = 0;
	    }
		  
	  *string_to_free = (void *)O_document;
	  *string_to_parse = (char *)O_document->arr;
	  *string_to_parse_len = O_document_size;
	  (*string_to_parse)[O_document_size] = '\0';
	  fovdPrintLog (LOG_DEBUG, "GetTimmFromPrimaryCursor: Successfully read document\n");

	  /* copy additional columns to 'stCol' */	  
	  if (O_contract_id_ind == 0) 
	    {
	      stCol->lContId = O_contract_id;
	    } 
	  else 
	    {
	      stCol->lContId = 0;
	    }

	  if (stBgh.fDbBscs4 == TRUE) 
	    {
	      if (O_cslevel_ind == 0) 
		{
		  STRCPY_FROM_ORA (stCol->szCsLevel, O_cslevel);
		} 
	      else 
		{
		  stCol->szCsLevel[0] = '\0';
		}
			  
	      if (O_bill_ins_ind == 0) 
		{
		  STRCPY_FROM_ORA (stCol->szBillIns, O_bill_ins_cd);
		} 
	      else 
		{
		  stCol->szBillIns[0] = '\0';
		}
	    }
	} /* end if rc == 0 */
    }   /* if((*end_indicator == FALSE) && (rc ==0)) */
  
  return (rc);  
} 
/* end GetTimmFromDatabase subroutine */




/****************************************************************/
/*                                                              */
/* ABSTRACT : Reading again document if the buffer was to small */
/*                                                              */
/* DESCRIPTION :                                                */
/*                                                              */
/* If the input buffer was to small to read the whole           */
/* document, the buffer is expanded and the document is read    */
/* once more.                                                   */
/*                                                              */
/* CALLED SUBROUTINES :                                         */
/*                                                              */
/*                                                              */
/*                                                              */
/* RETURN CODES :                                               */
/*                                                              */
/*   0           : The function worked properly                 */
/*   ERRORS                                                     */
/*  ESQL_REALLOC : realloc                                      */
/*  ESQL_SELECT  : selecting                                    */
/*                                                              */
/****************************************************************/

int ReadAgainFromDatabase(TYPEID timm_type)
{
  int rc = 0;
  
  O_document = (tLONGVARCHARPTR) malloc (O_document_size + sizeof (tLONGVARCHAR) + 1);
  if (O_document == NULL)
    {
      rc = ESQL_REALLOC;
      sprintf(message, "ReadAgainFromDatabase: Could not REallocate memory");
      macErrorMessage (rc, CRITICAL, message);
    }

  if(rc == 0) /* buffer successfully expanded */
    {
      O_document->len = O_document_size; /* real BLOB-length */
      
      EXEC SQL AT :O_db_name
	SELECT  document
	INTO    :O_document INDICATOR :O_document_ind
	FROM    document_all
	WHERE   rowid = :O_rowid_curr;
	  
      if (sqlca.sqlcode != 0)
	{
	  rc = ESQL_SELECT;
	  count_attempt = 0;
	  sprintf (message, "%s%s%d%s",
		   "ReadAgainFromDatabase:",
		   " Selected again document with usage: ",
		   timm_type,
		   " failed.");
	  sqlerror (rc, message);
	}
      else
	{
	  fovdPrintLog (LOG_DEBUG,
			"ReadAgainFromDatabase: Successfully reread document, %d bytes, %16.16s\n",
			O_document_size, O_document->arr);
	} /* end if sqlca.sqlcode */
    } /* end if rc == 0 */

  return (rc);
} /* end ReadAgainFromDatabase subroutine */

/*************************************************************/
/*                                                           */
/* ABSTRACT : (dis)connects to the database                  */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Connecting to the database and disconnecting if it        */
/* was connected before.                                     */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                : The function worked properly         */
/*   ERRORS                                                  */
/*  ESQL_DBCONNECT    : connect                              */
/*  ESQL_DBDISCONNECT : disconnect                           */
/*                                                           */
/*************************************************************/

int foiHandleDatabase (HANDLE handle, char *username, char *password)
  /* handle = connect or disconnect     */
{

   int rc;
   char *cs;
   rc = 0;

   /* connecting to the database */
   if (handle == connect)
   {
     cs = getenv("BSCS_CONNECT");
     if (cs == NULL)
       {
         STRCPY_TO_ORA(O_username, username);
         STRCPY_TO_ORA(O_password, password);
         STRCPY_TO_ORA(O_db_name, "BSCS_DB");
         STRCPY_TO_ORA(O_connect_string, connect_string);
         
         fovdPrintLog (LOG_DEBUG, "Trying to connect to database ...\n");
         
         EXEC SQL CONNECT  :O_username
           IDENTIFIED BY  :O_password
           AT  :O_db_name
           USING  :O_connect_string;
       }
     else
       {
         STRCPY_TO_ORA(O_db_name, "BSCS_DB");
         EXEC SQL CONNECT :cs
           AT :O_db_name;
       }

     if (sqlca.sqlcode == 0)
       {
         rc = 0;
         connected = TRUE;
         fovdPrintLog (LOG_DEBUG, "Connected to database\n");
         STRCPY_TO_ORA(O_processed, STATUS_PROCESSED);
         /* the same throughout the   */
         /* program                   */
       }
     else
       {
         rc = ESQL_DBCONNECT;
         count_attempt = 0;
         sprintf(message, "%s\n", "Could not connect to database in module: foiHandleDatabase");
         sqlerror(rc, message);
       }
   
     /*
       EXEC SQL ALTER SESSION SET NLS_LANG = Polish_Poland.EE8ISO8859P2 ;
       
      if (sqlca.sqlcode != 0)
      {
      rc = ESQL_SET_NLS_LANG;
      sprintf(message, "%s\n", "Could not set language in module: foiHandleDatabase");
      sqlerror(rc, message);
      }          
     */
     
   } /* handle == connect */
   
   /* disconnecting from database if connected                  */
   if ((handle == disconnect) && (connected == TRUE))
     {
	 /*
       EXEC SQL AT :O_db_name ROLLBACK WORK RELEASE;
       
       if (sqlca.sqlcode == 0)
         {
           rc = 0;
           fovdPrintLog (LOG_DEBUG, "Disconnected from database\n");
         }
       else
        {
          rc = ESQL_DBDISCONNECT;
          count_attempt = 0;
          sprintf(message, "Disconnect failed in module: foiHandleDatabase\n");
          sqlerror(rc, message);
        }
	 */
     } /* ((handle == disconnect) && (connected == TRUE)) */
   
   return (rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Fixes the changes made in the database         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/*  ESQL_COMMIT         : commit                             */
/*  ESQL_COMMIT_DBCLOSED: commit with closed database        */
/*                                                           */
/*************************************************************/

int foiCommitWork()

{
  int rc = 0;
  static int n = 0;
  
  if (connected == TRUE) /* try commit only with database open */
    {
      EXEC SQL AT :O_db_name COMMIT WORK;
      if (sqlca.sqlcode == 0)
        {
          rc = 0;
          fovdPrintLog (LOG_CUSTOMER, "Committed\n");
        }
      else
        {
          rc = ESQL_COMMIT;
          count_attempt = 0;
          sprintf(message, "Commit work failed in module: foiCommitWork");
          sqlerror(rc, message);
        }
    }
  else
    {
      rc = ESQL_COMMIT_DBCLOSED;
      sprintf(message, "Trying commit with database closed\n");
      macErrorMessage(rc, NORMAL, message);
    }
  
  FreeStack ();			/* free the rowid stack */

#ifdef _BGH_COMMIT_LIMIT_
  if (NULL != getenv("BGH_COMMIT_LIMIT"))
    {
      if (n++ == atoi(getenv("BGH_COMMIT_LIMIT")))
	{
	  return -1;
	}
    }
#endif

  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Rolls back changes made in the database        */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Roll  back work deletes all the changes made in the       */
/* database since the last commit. This function is called   */
/* if an error occurred somewhere during the main process    */
/* of the database before post-processing is called.         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_ROLLBACK          : ROLLBACK_FAILED                  */
/* ESQL_ROLLBACK_DBCLOSED : rollback with closed database    */
/*                                                           */
/*************************************************************/

int foiRollbackWork(void)
{
  int rc = 0;

  count_attempt++;

  if (connected == TRUE) /* try to rollback only with database open */
    {
      sprintf(message, "ATTEMPTING TO ROLLBACK WORK ... ");
      fprintf(stdout, "%s\n", message);
      EXEC SQL AT :O_db_name ROLLBACK WORK;
      if (sqlca.sqlcode != 0)
        {
          rc = ESQL_ROLLBACK;
          sprintf(message, "%s\n%s\n\n",
                  "ROLLBACK WORK FAILED --> VERY CRITICAL ERROR",
                  "Ability to restart gracefully is not guaranteed!");
          sqlerror(rc, message);
        }
      else
        {
          fovdPrintLog(LOG_DEBUG, "SUCCESSFULLY ROLLED BACK WORK\n");
        }
    }
  else
    {
      rc = ESQL_ROLLBACK_DBCLOSED;
      sprintf(message, "Trying rollback with database closed\n");
      macErrorMessage(rc, NORMAL, message);
    }
  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Handles errors occurred  dealing with database */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Writes a message to the error file if an error occurred   */
/* in dealing with the database. The message contains        */
/* various information given by the database and some        */
/* information given by the calling function.                */
/*                                                           */
/*       SUBROUTINES :                                       */
/*                                                           */
/*  foiRollbackWork()                                        */
/*                                                           */
/*************************************************************/

void sqlerror(
              int code,         /* self-defined error-code   */
              char *occurrence  /* location where the error  */
             )                  /* occurred and additional   */
                                /* information               */
#define MAX_SQL_MESSAGE 512
{
/* These vars are only used to get the oracle long-message   */
   char message_buf[ MAX_SQL_MESSAGE + 1];
   size_t buf_len = MAX_SQL_MESSAGE;
   size_t msg_len;

   if (sqlca.sqlcode < 0) {
     /* to get the oracle long-message */
     sqlglm (message_buf , &buf_len, &msg_len); /* sqlglm is a ORACLE function */
     message_buf[msg_len] = '\0';
#if 0
     sprintf(message_buf, "%s%s\n%s%d\n%s%ld\n%s%s\n%s%s\n%s",
	     "SQL-ERROR in file: ", __FILE__,
	     "Module ERROR-code: ", code,
	     "SQL-code:          ", sqlca.sqlcode,
	     "Description:       ", occurrence,
	     "SQL-Short message: ", sqlca.sqlerrm.sqlerrmc,
	     "SQL-Full message: ");
#else
     sprintf(message, "%s%s\n%s%d\n%s%ld\n%s%s\n%s%s",
	     "SQL-ERROR in file: ", __FILE__,
	     "Module ERROR-code: ", code,
	     "SQL-code:          ", sqlca.sqlcode,
	     "Description:       ", occurrence,
	     "SQL-Full message:  ", message_buf);
#endif
     macErrorMessage (code, WARNING, message);

/* to avoid an endless loop if the rollback failed this code */
/* is tested                                                 */
     if ((code != ROLLBACK_FAILED) && (count_attempt < MAX_ATTEMPTS))
     {
       (void) foiRollbackWork();
     }
   }
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : opens the primary/main cursor                  */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor and closes the cursor if it was opened.  */
/* Also initiates   some of the data which is used global    */
/* within this file.                                         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_OPENMAINCURSOR    : open main cursor                 */
/*                                                           */
/*************************************************************/

int fnOpenPrimaryCursor( TYPEID   usage_type,   /* INV, ENC for main cursor,  */
                                                /* ITB, SUM, ROA, LGN, BAL for second cursor */
                         TYPECUST cust_process, /* MULTIPLE or SINGLE, only for main cursor  */
                         long poiBghId)	      /* ID of running BGH			    */	
{
   int rc;
   rc = 0;

   O_usage_prim = usage_type;
   O_BghId      = poiBghId;

   if (cust_process == MULTIPLE)
   {
     fovdPrintLog (LOG_DEBUG,
                   "Open main cursor for DOCUMENT_ALL with:\n"
                   "     TYPE_ID     = %d\n", usage_type);
     
#ifdef BSCS4
     if (stBgh.fDbBscs4 == TRUE) 
       {
         EXEC SQL OPEN Cnewmain_cursor;
     
       } 
     else
#endif
       {
         EXEC SQL OPEN   Cmain_cursor;
       }
     status_single = FALSE;
   } 
   else 
     {
       O_customer_id = stBgh.lCustId;

       fovdPrintLog (LOG_DEBUG,
                     "Open single main cursor for DOCUMENT_ALL with:\n"
                     "     TYPE_ID     = %d\n"
                     "     CUSTOMER_ID = %ld\n",
                     usage_type, O_customer_id);
       
#ifdef BSCS4
       if (stBgh.fDbBscs4 == TRUE) 
         {
           EXEC SQL OPEN Cnewsingle_main_cursor;
         } 
       else
#endif
         {
           EXEC SQL OPEN   Csingle_main_cursor;
         }
       status_single = TRUE;
     }
   if (sqlca.sqlcode != 0)
     {
       rc = ESQL_OPENMAINCURSOR;
       count_attempt = 0;
       sprintf (message, "foiHandleCursor: Could not open main cursor");
       sqlerror (rc, message);
     }
   else
     {
       fovdPrintLog (LOG_DEBUG,
                     "Opened Cursor: Cmain_cursor, with usage_type: %d\n",
                     usage_type);
   }
#if TRACESQL
   if (usage_type == INV_TYPE) 
     {
       EXEC SQL AT :O_db_name ALTER SESSION set sql_trace=true;
       printf ("Alter session... %d %s\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
     }
#endif
  
    return (rc);       
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : opens the secondary cursor                     */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor and closes the cursor if it was opened.  */
/* Also initiates   some of the data which is used global    */
/* within this file.                                         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_OPENSECONDCURSOR  : open second cursor               */
/*                                                           */
/*************************************************************/

int fnOpenSecondaryCursor( TYPEID   usage_type)	/* ITB, SUM, ROA, LGN, BAL for second cursor */
{
   int rc;
   rc = 0;

   O_usage_curr = usage_type;

   fovdPrintLog (LOG_DEBUG,
                 "Open second cursor for DOCUMENT_ALL in '%s' with:\n"
                 "     TYPE_ID     = <%d>\n"
                 "     CUSTOMER_ID = <%ld>\n"
                 "     BGH_PROCESS = <%ld>\n"
                 "     DATE_CREATED= <%.10s>\n", O_db_name.arr,
                 usage_type, O_customer_id, O_unique_id, O_date_created.arr);
   
#ifdef BSCS4
   if (stBgh.fDbBscs4 == TRUE) 
     {
       EXEC SQL OPEN Cnewsecond_common_cursor;
     } 
   else
#endif
     {	 
       EXEC SQL OPEN Csecond_common_cursor;
     }

   if (sqlca.sqlcode != 0)
     {
       rc = ESQL_OPENSECONDCURSOR;
       count_attempt = 0;
       sprintf(message, "foiHandleCursor: Could not open second cursor ");
       sqlerror(rc, message);
     }
   else
     {
       fovdPrintLog(LOG_DEBUG,
                    "Opened Cursor: Csecond_cursor, with usage_type: %d\n",
                    usage_type);
     }
   
   return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : closes the primary/main cursor                 */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor and closes the cursor if it was opened.  */
/* Also initiates   some of the data which is used global    */
/* within this file.                                         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_CLOSEMAINCURSOR   : close main cursor                */
/*                                                           */
/*************************************************************/

int fnClosePrimaryCursor( TYPEID   usage_type,  /* INV for main cursor,  */
                          /* ITB, SUM, ROA, LGN, BAL for second cursor */
                          TYPECUST cust_process) /* MULTIPLE or SINGLE, only for main cursor */
{
  int rc;
  rc = 0;

  /* close main cursor */
     if (cust_process == MULTIPLE)
     {
#ifdef BSCS4
       if (stBgh.fDbBscs4 == TRUE) {
	     EXEC SQL CLOSE Cnewmain_cursor;
       } else
#endif
       {
         EXEC SQL CLOSE  Cmain_cursor;
       }
     }
     else 
     {
#ifdef BSCS4
       if (stBgh.fDbBscs4 == TRUE) {
	     EXEC SQL CLOSE Cnewsingle_main_cursor;
       } else
#endif
       {
         EXEC SQL CLOSE  Csingle_main_cursor;
       }
     } 
     if (sqlca.sqlcode != 0)
     {
       rc = ESQL_CLOSEMAINCURSOR;
       count_attempt = 0;
       sprintf (message, "foiHandleCursor: Could not close main cursor ");
       sqlerror (rc, message);
     } else 
     {
       O_usage_prim = -1;
       
       if (status_single == FALSE)
       {
         fovdPrintLog (LOG_DEBUG,
			   "Closed Cursor: Cmain_cursor, with usage_type: %d\n",
			   usage_type);
       }
       else
       {
         fovdPrintLog (LOG_DEBUG,
			   "Closed Cursor: Csingle_main_cursor, with usage_type: %d\n",
			   usage_type);
       }
       status_single = FALSE;
     }
     return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : opens the secondary cursor                     */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor and closes the cursor if it was opened.  */
/* Also initiates   some of the data which is used global    */
/* within this file.                                         */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                    : The function worked properly     */
/*   ERRORS                                                  */
/* ESQL_CLOSESECONDCURSOR : close second cursor              */
/*                                                           */
/*************************************************************/

int fnCloseSecondaryCursor( TYPEID   usage_type)  /* ITB, SUM, ROA, LGN, BAL for second cursor */
{
  int rc;
  
  rc = 0;

#ifdef BSCS4
  if (stBgh.fDbBscs4 == TRUE)
    EXEC SQL CLOSE Cnewsecond_common_cursor;
  else
#endif
    EXEC SQL CLOSE  Csecond_common_cursor;
  if (sqlca.sqlcode != 0)
    {
	   rc = ESQL_CLOSESECONDCURSOR;
	   count_attempt = 0;
	   sprintf(message, "foiHandleCursor: Could not close second cursor ");
	   sqlerror(rc, message);
    }
  else
    {
      fovdPrintLog (LOG_DEBUG,
                    "Closed Cursor: Csecond_cursor, with usage_type: %d\n",
                    usage_type);
    }
  return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : opens and closes the test cursor               */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* Opens the cursor and closes the cursor if it was opened.  */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_OPENTESTCURSOR  : open test cursor                   */
/* ESQL_CLOSETESTCURSOR : close test cursor                  */
/*                                                           */
/*************************************************************/

int foiHandleTestCursor (HANDLE handle /* sql_open or sql_close */)
{

   static int opened_test   = FALSE; /* stores status of test cursor   */

   int rc = 0;

   /* open test cursor if not open yet */
   if ((handle == sql_open) && (opened_test == FALSE))
   {

     EXEC SQL OPEN   Ctest_cursor;
     if (sqlca.sqlcode != 0)
     {
       rc = ESQL_OPENTESTCURSOR;
       count_attempt = 0;
       sprintf(message, "foiHandleTestCursor: Could not open test cursor ");
       sqlerror(rc, message);
     }
     else
     {
       opened_test = TRUE;
       fovdPrintLog (LOG_DEBUG, "Opened Cursor: Ctest_cursor\n");
     }
   } /* handle == open */

   /* close test cursor if it is open */
   if ((handle == sql_close) && (opened_test == TRUE))
   {
     EXEC SQL CLOSE  Ctest_cursor;
     if (sqlca.sqlcode != 0)
     {
       rc = ESQL_CLOSETESTCURSOR;
       count_attempt = 0;
       sprintf(message, "foiHandleTestCursor: Could not close test cursor ");
       sqlerror(rc, message);
     }
     else
     {
       EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
       opened_test = FALSE;
       fovdPrintLog (LOG_DEBUG, "Closed Cursor: Ctest_cursor\n");
     }
   } /* handle == close */
   return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT :  resets X-Marks for processed rows.            */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* RETURN CODES  :                                           */
/*                                                           */
/*   0           : The function worked properly              */
/*   ERRORS                                                  */
/* ESQL_SELCOUNT : selecting count(*)                        */
/* ESQL_RESETX   : updating reset X's                        */
/* ESQL_NOX      : nothing to reset                          */
/*                                                           */
/*************************************************************/

int foiEraseX() {
   int rc, i;
   rc = 0;

   O_processed_ind = -1;   /* ORACLE will assign a null to the column,  */
                           /* ignoring the value of the host variable.  */
                           /* Initialization  of O_processed already    */
                           /* occured in the function foiHandleDatabase */

   EXEC SQL AT  :O_db_name
     UPDATE  document_all
     SET  processed_by_bgh = :O_processed INDICATOR :O_processed_ind
     WHERE  processed_by_bgh IS not null;
   /* if you just want to reset the 'X', replace the former line by this one */
   /* WHERE  processed_by_bgh = :O_processed; */

   if (sqlca.sqlcode != 0) {
     /* if != NO_MORE_DATA */
     if (sqlca.sqlcode != 1403) {
       rc = ESQL_RESETX;
       count_attempt = 0;
       sprintf(message, "%s%s\n", "Updating document_all, reset as processed failed in module: ", "EraseX");
       sqlerror(rc, message);     
     } 
     else { 
       fovdPrintLog (LOG_NORMAL, "EraseX: Nothing to reset\n");
     }
   }
   else {
     fovdPrintLog (LOG_NORMAL, "EraseX: Updated document_all, resets %ld record(s) as processed\n", sqlca.sqlerrd[2]);
   }
 
   return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : writes bill_images                             */
/*                                                           */
/* DESCRIPTION : inserting bills into bill_images-           */
/*               databasetable                               */
/*                                                           */
/* RETURN CODES     :                                        */
/*                                                           */
/*   0               : The function worked properly          */
/*   ERRORS                                                  */
/* ESQL_BILLINSERT   : Inserting                             */
/* ESQL_BILL_ILLTYPE : Illegal timm-type for bill-image      */
/* ESQL_BILL_DBCLOSED: Trying to insert with closed database */
/* ESQL_BILL_NULL    : No image-data information             */
/*                                                           */
/*************************************************************/

int PutBillIntoDatabase(
                        char *bill_image_string, /* image-information */
                        TYPEID timm_type,
                        stDBCOL *stCol 		/* add. columns */
                       )
{
  int 	      	rc;
#if 0
  time_t      	tiCurrent;
  struct tm   	*tmCET;
  int         	iYear;
#endif

  rc = 0;

  fovdPrintLog (LOG_DEBUG, "Trying to insert data into bill_images\n");

#if 0
  /*
   * get the current date and time
   */
  tiCurrent = 0;
  tiCurrent = time (&tiCurrent);
  tmCET = localtime (&tiCurrent);
  iYear = tmCET->tm_year + 1900;
  if (tmCET->tm_year < 90) {
    iYear += 100;
  }
  sprintf (current_date_created, "%02d-%02d-%04d",
           tmCET->tm_mday, tmCET->tm_mon + 1, iYear);
#endif
  STRCPY_TO_ORA (O_date_inserted, current_date_created);

  if (connected == FALSE)
    {
      rc = ESQL_BILL_DBCLOSED;
      sprintf (message, "PutBillIntoDatabase: Trying to insert with database closed");
      macErrorMessage (rc, WARNING, message);
    }

  if (rc == 0)
  {
    if (bill_image_string == NULL)
    {
      rc = ESQL_BILL_NULL;
      sprintf (message, "PutBillIntoDatabase: No image-information, nothing to insert");
      macErrorMessage (rc, NORMAL, message);
    }
    else if (strlen (bill_image_string) < 1)
    {
      rc = ESQL_BILL_NULL;
      sprintf (message, "PutBillIntoDatabase: No image-information, nothing to insert");
      macErrorMessage (rc, NORMAL, message);
    }
    else
    {
      O_bi_image = bill_image_string;
    }
  }

  if (rc == 0)
  {
#ifdef BSCS4
    if (stBgh.fDbBscs4 == FALSE)
#endif
    {
      switch (timm_type)
      {
      case INV_TYPE:
        STRCPY_TO_ORA (O_bi_type, "B");
        break;
      case ITB_TYPE:
        STRCPY_TO_ORA (O_bi_type, "I");
        break;
      default:
        rc = ESQL_BILL_ILLTYPE;
        sprintf (message,
                 "PutBillIntoDatabase: Unexpected timm-type: %d for bill-image",
                 timm_type);
        macErrorMessage (rc, WARNING, message);
        break;
      }
    }
  }

  if (rc == 0)
  {
    if (stCol->lContId >= 0) {
      O_contract_id 	= stCol->lContId;
      O_contract_id_ind = 0;
    } else {
      O_contract_id_ind = -1;
    }

    STRCPY_TO_ORA (O_bi_image_process, BI_IMAGE_PROCESS);
    STRCPY_TO_ORA (O_bi_image_process, stBgh.szBIProcessProgram);
    STRCPY_TO_ORA (O_bi_extension, BI_EXTENSION);

#ifdef BSCS4
    if (stBgh.fDbBscs4 == TRUE)
    {
      int len;

      O_contrgr_ind = -1;	/* set column to NULL */
      O_testbr_ind  = -1;	/* set column to NULL */
      O_bitypnr = stCol->lTypeId;
      O_copies  = stCol->lCopies;

      STRCPY_TO_ORA (O_bins_code, stCol->szBillIns);
      STRCPY_TO_ORA (O_cslevel, stCol->szCsLevel);

      /* allocate memory for the image */
      len = strlen (bill_image_string) + 3;
      O_rawimage = (tLONGRAWPTR) malloc (len + sizeof (long));

      if (O_rawimage == NULL)
      {
        /*
         * emit a critical error (which terminates the program)
         */
        macErrorMessage (ESQL_ALLOC, CRITICAL, 
                         "PutBillIntoDatabase: Memory allocation for image failed!");
        rc = (int) ESQL_ALLOC;
      }

      O_rawimage->len = len;
      memcpy (O_rawimage->buf, bill_image_string, len);
#ifdef _DEBUG_
      printf ("Insert 40x, DB %s\ncuid %ld, ohxact %ld, %d, bi_type %ld, bi_date: %s\n"
              "bi_im_proc: %s, ext: %s, co_id: %ld, coidind: %d,\n size: %d, copies: %ld\n"
              "cntr: %s, %d, testb: %s, %d, biins: %s, cslevel: %s %d, bi_image: %s\n",
              O_db_name.arr,
              O_customer_id, O_ohxact, O_ohxact_ind, O_bitypnr, O_date_inserted.arr,
              stBgh.szBIProcessProgram, BI_EXTENSION, O_contract_id, O_contract_id_ind,
              len, O_copies, O_contr_group.arr, O_contrgr_ind, O_testbrun.arr, O_testbr_ind,
              O_bins_code.arr, O_cslevel.arr, O_cslevel.len, bill_image_string);
#endif      
      O_imagesize = len;

      EXEC SQL AT  :O_db_name
      INSERT INTO  bill_images (customer_id,
                                ohxact,
                                bi_type,
                                bi_date,
                                bi_image,
                                bi_image_process,
                                bi_extension,
                                co_id,
                                bi_image_size,
                                no_of_copies,
                                contr_group,
                                testbillrun,
                                bill_ins_code,
                                cslevel)
                       VALUES  (:O_customer_id,
                                :O_ohxact INDICATOR :O_ohxact_ind,
                                :O_bitypnr,
                                to_date(:O_date_inserted, 'DD-MM-YYYY'),
                                :O_rawimage,
                                :O_bi_image_process,
                                :O_bi_extension,
                                :O_contract_id INDICATOR :O_contract_id_ind,
                                :O_imagesize,
                                :O_copies,
                                :O_contrgroup  INDICATOR :O_contrgr_ind,
                                :O_testbrun    INDICATOR :O_testbr_ind,
                                :O_bins_code,
                                :O_cslevel);
      if (O_rawimage != NULL)
      {
        free (O_rawimage);
        O_rawimage = NULL;
      }
    }
    else
#endif
    {
      EXEC SQL AT  :O_db_name
      INSERT INTO  bill_images (customer_id,
                                ohxact,
                                bi_type,
                                bi_date,
                                bi_image,
                                bi_image_process,
                                bi_extension,
                                co_id)
                       VALUES  (:O_customer_id,
                                :O_ohxact INDICATOR :O_ohxact_ind,
                                :O_bi_type,
                                to_date(:O_date_inserted, 'DD-MM-YYYY'),
                                :O_bi_image,
                                :O_bi_image_process,
                                :O_bi_extension,
                                :O_contract_id INDICATOR :O_contract_id_ind);
    }

    if (sqlca.sqlcode != 0)
    {
      rc = ESQL_BILLINSERT;
      count_attempt = 0;
      sqlerror (rc, "Inserting bill_images failed in module: PutBillIntoDatabase");
     }
     else
     {
       fovdPrintLog (LOG_DEBUG,
                     "PutBillIntoDatabase: Inserted data into database\n");
     }
  }
  return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : writes bill_images                             */
/*                                                           */
/* DESCRIPTION : inserting bills into bill_images-           */
/*               databasetable                               */
/*                                                           */
/* RETURN CODES     :                                        */
/*                                                           */
/*   0               : The function worked properly          */
/*   ERRORS                                                  */
/* ESQL_BILLINSERT   : Inserting                             */
/* ESQL_BILL_ILLTYPE : Illegal timm-type for bill-image      */
/* ESQL_BILL_DBCLOSED: Trying to insert with closed database */
/* ESQL_BILL_NULL    : No image-data information             */
/*                                                           */
/*************************************************************/

extern int PutImageIntoDatabase(
                                char *bill_image_string, /* image-information */
                                int bill_image_string_len,
                                char *bill_image_header_string, /* image-header-information */
                                int bill_image_header_string_len,
                                TYPEID timm_type,        /* type of document */
                                stDBCOL *stCol 		     /* add. columns */
                                )
{
  int rc = 0;
  time_t tiCurrent;
  struct tm *tmCET;
  int iYear;
  
  fovdPrintLog (LOG_DEBUG, "Trying to insert data into bill_images\n");
  
  /*
   * Check connection status
   */
  
  if (connected == FALSE)
    {
      rc = ESQL_BILL_DBCLOSED;
      sprintf (message, "PutBillIntoDatabase: Trying to insert with database closed");
      macErrorMessage (rc, WARNING, message);
    }
  
  /*
   * Get the current date and time
   */

  tiCurrent = 0;
  tiCurrent = time (&tiCurrent);
  tmCET = localtime (&tiCurrent);
  iYear = tmCET->tm_year + 1900;
  if (tmCET->tm_year < 90) 
    {
      iYear += 100;
    }
  
  sprintf (current_date_created, "%02d-%02d-%04d", tmCET->tm_mday, tmCET->tm_mon + 1, iYear);
  STRCPY_TO_ORA (O_date_inserted, current_date_created);
  
  if (rc == 0)
    {
      if (bill_image_string == NULL)
        {
          rc = ESQL_BILL_NULL;
          sprintf (message, "PutBillIntoDatabase: No image-information, nothing to insert");
          macErrorMessage (rc, NORMAL, message);
        }
      else if (bill_image_string_len < 1)
        {
          rc = ESQL_BILL_NULL;
          sprintf (message, "PutBillIntoDatabase: No image-information, nothing to insert");
          macErrorMessage (rc, NORMAL, message);
        }
      else
        {
          O_bi_image = bill_image_string;
        }
    }
  
  if (rc == 0)
    {
#ifdef BSCS4
      if (stBgh.fDbBscs4 == FALSE)
#endif
        {
            sprintf (message,
                       "PutImageIntoDatabase: Unexpected stBgh.fDbBscs4 == FALSE \n");
            macErrorMessage (rc, WARNING, message);
#if 0
          switch (timm_type)
            {
            case INV_TYPE:
              STRCPY_TO_ORA (O_bi_type, "B");
              break;
            case ITB_TYPE:
              STRCPY_TO_ORA (O_bi_type, "I");
              break;
            default:
              rc = ESQL_BILL_ILLTYPE;
              sprintf (message,
                       "PutImageIntoDatabase: Unexpected timm-type: %d for bill-image",
                       timm_type);
              macErrorMessage (rc, WARNING, message);
              break;
            }
#endif
        }
    }
  
  if (rc == 0)
    {      
      /*
       * What type of image we handle
       */

      if (stBgh.bCompressImage == TRUE)
        {
          STRCPY_TO_ORA (O_bi_image_process, stBgh.szBIZProcessProgram);
          STRCPY_TO_ORA (O_bi_extension, BIZ_EXTENSION);          
        }
      else
        {
          STRCPY_TO_ORA (O_bi_image_process, stBgh.szBIProcessProgram);
          STRCPY_TO_ORA (O_bi_extension, BI_EXTENSION);
        }
      
#ifdef BSCS4
      if (stBgh.fDbBscs4 == TRUE)
        {
          int len;
          
          O_contrgr_ind = -1;	/* set column to NULL */
          O_testbr_ind  = -1;	/* set column to NULL */
/*          O_bitypnr = INVOICE_IMAGE_TYPE; */
          O_bitypnr = timm_type;
          O_copies  = 1;
          
          /*
          STRCPY_TO_ORA (O_bins_code, stCol->szBillIns);
          STRCPY_TO_ORA (O_cslevel, stCol->szCsLevel);
          */

          /* allocate memory for the image */
          len = bill_image_header_string_len + bill_image_string_len + 3;
          fovdPrintLog (LOG_DEBUG, "image memory alloc: %d = %d + %d\n", len, bill_image_header_string_len, bill_image_string_len);
          fovdPrintLog (LOG_DEBUG, "header %s\n", bill_image_header_string);
          
          O_rawimage = (tLONGRAWPTR) malloc (len + sizeof (long));
          if (O_rawimage == NULL)
            {
              /*
               * emit a critical error (which terminates the program)
               */
              
              macErrorMessage (ESQL_ALLOC, CRITICAL, 
                               "PutBillIntoDatabase: Memory allocation for image failed!");
              rc = (int) ESQL_ALLOC;
            }
          
          O_rawimage->len = len;         
          memcpy (O_rawimage->buf, bill_image_header_string, bill_image_header_string_len);
          memcpy (O_rawimage->buf + bill_image_header_string_len, bill_image_string, bill_image_string_len);
#ifdef _DEBUG_
          printf ("Insert 40x, DB %s\ncuid %ld, ohxact %ld, %d, bi_type %ld, bi_date: %s\n"
                  "bi_im_proc: %s, ext: %s, co_id: %ld, coidind: %d,\n size: %d, copies: %ld\n"
                  "cntr: %s, %d, testb: %s, %d, biins: %s, cslevel: %s %d, bi_image: %s\n",
                  O_db_name.arr,
                  O_customer_id, O_ohxact, O_ohxact_ind, O_bitypnr, O_date_inserted.arr,
                  stBgh.szBIProcessProgram, BI_EXTENSION, O_contract_id, O_contract_id_ind,
                  len, O_copies, O_contr_group.arr, O_contrgr_ind, O_testbrun.arr, O_testbr_ind,
                  O_bins_code.arr, O_cslevel.arr, O_cslevel.len, O_rawimage->buf);
#endif      
          O_imagesize = len;
          
          EXEC SQL AT  :O_db_name
            INSERT INTO  bill_images (customer_id,
                                      ohxact,
                                      bi_type,
                                      bi_date,
                                      bi_image,
                                      bi_image_process,
                                      bi_extension,
                                      co_id,
                                      bi_image_size,
                                      no_of_copies,
                                      contr_group,
                                      testbillrun,
                                      bill_ins_code,
                                      cslevel)
            VALUES  (:O_customer_id,
                     :O_ohxact INDICATOR :O_ohxact_ind,
                     :O_bitypnr,
                     to_date(:O_date_inserted, 'DD-MM-YYYY'),
                     :O_rawimage,
                     :O_bi_image_process,
                     :O_bi_extension,
                     :O_contract_id INDICATOR :O_contract_id_ind,
                     :O_imagesize,
                     :O_copies,
                     :O_contrgroup  INDICATOR :O_contrgr_ind,
                     :O_testbrun    INDICATOR :O_testbr_ind,
                     :O_bins_code,
                     :O_cslevel);
          
          if (O_rawimage != NULL)
            {
              free (O_rawimage);
              O_rawimage = NULL;
            }
        }
      else
#endif
        {
          EXEC SQL AT  :O_db_name
            INSERT INTO  bill_images (customer_id,
                                      ohxact,
                                      bi_type,
                                      bi_date,
                                      bi_image,
                                      bi_image_process,
                                      bi_extension,
                                      co_id)
            VALUES  (:O_customer_id,
                     :O_ohxact INDICATOR :O_ohxact_ind,
                     :O_bi_type,
                     to_date(:O_date_inserted, 'DD-MM-YYYY'),
                     :O_bi_image,
                     :O_bi_image_process,
                     :O_bi_extension,
                     :O_contract_id INDICATOR :O_contract_id_ind);
        }
      
      if (sqlca.sqlcode != 0)
        {
          rc = ESQL_BILLINSERT;
          count_attempt = 0;
          sqlerror (rc, "Inserting bill_images failed in module: PutImageIntoDatabase");
        }
      else
        {
          fovdPrintLog (LOG_DEBUG, "PutImageIntoDatabase: Inserted data into database\n");
        }
    }

  return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT      :  allocates memory for an array of rowid's.*/
/*                  Puts the rowid's on the stack.           */
/*                                                           */
/* DESCRIPTION   :                                           */
/*                                                           */
/*                                                           */
/* RETURN CODES  :                                           */
/*                                                           */
/*   0           : The function worked properly              */
/*   ERRORS                                                  */
/* ESQL_ALLOC    : by malloc                                 */
/* ESQL_REALLOC  : by realloc                                */
/*                                                           */
/*************************************************************/

int foiPutOnStack (BOOL bPrimary)
{
   int rc;
   int i;
   char *temp_ptr;
   static char **temp_arr_ptr = NULL;
   static int dim_of_array;
   static int dim_of_array_old;

   rc = 0;

   if (bPrimary)
   {
     dim_of_array = DEF_DIM_STACK;
     dim_of_array_old = 0;
     n_of_elem = 0;

     fovdPrintLog (LOG_DEBUG,
		   "bgh_esql: Allocating memory for stack\n");

     temp_arr_ptr = (char **)malloc(dim_of_array*sizeof(char *));
     if (temp_arr_ptr == NULL)
     {
       rc = ESQL_ALLOC;
       sprintf(message, "foiPutOnStack: Could not allocate memory for stack of rowid's");
       macErrorMessage(rc, CRITICAL, message);
     }
     else
     {
       for (i = dim_of_array_old; i < dim_of_array; i++)
       {
         *(temp_arr_ptr + i) = NULL;
       }
       rowid_array = temp_arr_ptr;
     }
   } /* end if bPrimary... */

   if (n_of_elem >= dim_of_array)
   {
     dim_of_array_old = dim_of_array;
     dim_of_array *= 2;

     free(temp_arr_ptr);
     temp_arr_ptr = (char **)malloc(dim_of_array*sizeof(char *));
     if (temp_arr_ptr == NULL)
     {
       rc = ESQL_REALLOC;
       sprintf(message, "foiPutOnStack: Could not REallocate memory for stack of rowid's");
       macErrorMessage(rc, CRITICAL, message);
     }
     else
     {
       for (i = dim_of_array_old; i < dim_of_array; i++)
       {
         *(temp_arr_ptr + i) = NULL;
       }
       rowid_array = temp_arr_ptr;
     }
   } /* end if n_of_elem... */

   temp_ptr = (char *)malloc(ROWID_ELEM_SIZE*sizeof(char));
   if( temp_ptr == NULL)
   {
     rc = ESQL_ALLOC;
     sprintf (message,
	      "foiPutOnStack: Could not allocate memory for the rowid element number: %d",
	      n_of_elem);
     macErrorMessage (rc, CRITICAL, message);
   }
   else
   {
     *(temp_arr_ptr + n_of_elem) = temp_ptr;
     STRCPY_FROM_ORA (temp_ptr, O_rowid_curr);
     n_of_elem++;
   }

   return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT      : frees storage earlier allocated or        */
/*                 reallocated by malloc or realloc in       */
/*                 function foiPutOnStack                    */
/*                                                           */
/* DESCRIPTION   :                                           */
/*                                                           */
/*                                                           */
/* RETURN CODES  : none                                      */
/*                                                           */
/*************************************************************/

void FreeStack(void)
{
  int i;
  
  if (rowid_array == NULL) return;
  
  fovdPrintLog (LOG_DEBUG, "bgh_esql: Freeing memory for stack\n");
  
  for (i = 0; i < n_of_elem; i++)
    {
      if (rowid_array[i] != NULL)
        {
          free((void *)(rowid_array[i]));
          rowid_array[i] = NULL;
        }
    }
  
  free((void *)rowid_array);
  rowid_array = NULL;
  
  return;
}

/*************************************************************/
/*                                                           */
/* ABSTRACT      :  Marks processed rows for a customer.     */
/*                                                           */
/* DESCRIPTION   :                                           */
/* To mark all rows (=document) for a customer as processed. */
/* This is used to make it possible to restart the BGH where */
/* it crashed without writing the same document twice.       */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES:                                       */
/*                 MarkProcessed() - embedded-SQL            */
/*                                                           */
/* RETURN CODES  :                                           */
/*                                                           */
/*   0           : The function worked properly              */
/*   ERRORS                                                  */
/*   X           : Error codes delivered by subroutines      */
/*                                                           */
/*************************************************************/

int foiMarkCustomer(char *marker)
{
  int rc;
  int i;
  
  rc = 0;
  
  STRCPY_TO_ORA (O_cust_processed, marker);

  for (i = 0; i < n_of_elem; i++)
    {
      rc = MarkProcessed(*(rowid_array + i));
      if (rc != 0)
        {
          sprintf (message,
                   "foiMarkCustomer: Could not mark document-number: "
                   "%d for customer_id: %ld",
                   i, current_customer_id);
          macErrorMessage(rc, CRITICAL, message);
          break;
        }
    }
  
  if (rc == 0)
    {
      fovdPrintLog (LOG_DEBUG,
                    "foiMarkCustomer: Updated document_all, set customer with "
                    "customer_id: %ld as processed\n",
                    current_customer_id);
    }
  
  
  return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT :  Marks processed rows.                         */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/* To mark an row (=document) as processed.                  */
/* This is used to make it possible to restart the BGH where */
/* it crashed without writing the same document twice.       */
/*                                                           */
/* Roaming-pages are not marked!                             */
/*                                                           */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                   : The function worked properly      */
/*   ERRORS                                                  */
/*  ESQL_UPDATE          : updating                          */
/*  ESQL_UPDATEMOREASONE : updated more than one document    */
/*                                                           */
/*************************************************************/

int MarkProcessed(char *rowid_from_stack) {
   int rc;

   rc = 0;

   STRCPY_TO_ORA(O_rowid_stack, rowid_from_stack);
   
   if (getenv("BSCS_CONNECT") != NULL)
     {
       return 0;
     }

   fovdPrintLog (LOG_DEBUG, "MarkProcessed: Setting DOCUMENT_ALL.PROCESSED_BY_BGH\n");   
   EXEC SQL AT :O_db_name
     UPDATE  document_all
     SET  processed_by_bgh = :O_cust_processed
     WHERE  rowid = :O_rowid_stack;
   
   if (sqlca.sqlcode != 0) 
     {
       rc = ESQL_UPDATE;
       count_attempt = 0;
       sprintf(message, "%s%s\n", "Updating document_all, set as processed failed in module: ", "MarkProcessed");
       sqlerror(rc, message);
     }
   
   if ((sqlca.sqlerrd[2] != 1) && (rc == 0)) 
     { 
       /* 
        * the number of rows processed by the most recently SQL statement 
        */
       rc = ESQL_UPDATEMOREASONE;
       sprintf(message, "%s%ld%s", "ERROR updated ",  sqlca.sqlerrd[2], " rows, but just one should it be!");
       macErrorMessage(rc, WARNING, message);
     }

   if (rc == 0) 
     {
       fovdPrintLog (LOG_DEBUG, "MarkProcessed: Updated document_all, set record as processed\n");
     }
   
   return (rc);
}

#ifdef BSCS4

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading DOC_TYPE tables for document           */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/

static int fnGetDocType(void) {
  int  rc;
  int	i;
  
  rc  = 0;
  pstDocTypes = NULL;
  
  fovdPrintLog (LOG_CUSTOMER, "Trying to get DOC_TYPES table\n");

  /*
   * read the count for the entries of DOC_TYPES
   */
  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM doc_types;

  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "GetDocTables: Selected count(*) on DOC_TYPES failed.");
    sqlerror (rc, message);
  }

  fovdPrintLog (LOG_DEBUG, "GetDocTables: %d entries for DOC_TYPES\n", T_count);

  pstDocTypes = (stDOCTYPES *) malloc (sizeof (stDOCTYPES) * (T_count + 1));

  if (pstDocTypes == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"GetDocTables\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstDocTypes[T_count].lTypeId = -1;

  if ((rc == 0) && (T_count != 0)) {
    /*
     * read table DOC_TYPES from database
     */

    EXEC SQL OPEN   Cdoc_type;

    if (sqlca.sqlcode == SQL_INVCOLUMN) {
      /* column is invalid -> it is a BSCS3xx database */
      rc = ESQL_INV_COLUMN;

      fovdPrintLog (LOG_CUSTOMER, "Invalid column in DOC_TYPES, no BSCS 4.x database!\n");
    }
    else if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not open Cdoc_type cursor ");
      sqlerror (rc, message);
    }
    else {
      /*
       * succesfully opened cursor with new column
       * -> we have a BSCS4 database
       */
      stBgh.fDbBscs4 = TRUE;
#ifdef _DEBUG_
      printf("Cdoc_type OPEN status is OK\n");
#endif
    }

    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cdoc_type INTO
        :O_type_id,
        :O_gen_this_msg INDICATOR :O_gen_ind;

      switch (sqlca.sqlcode) {
      case 0:			/* no error */
        if (O_gen_ind == -1) {
          /* GEN_THIS_MSG is NULL !! */
          pstDocTypes[i].cGenThisMsg = '\0';
#ifdef _DEBUG_
          printf("pstDocTypes[%d]\tcGenThisMsg #, lTypeId %d\n", O_type_id); 
#endif
        } else {
          pstDocTypes[i].cGenThisMsg = O_gen_this_msg.arr[0];
#ifdef _DEBUG_
          printf("pstDocTypes[%d]\tcGenThisMsg %c, lTypeId %d\n", i, O_gen_this_msg.arr[0], O_type_id); 
#endif
        }
        pstDocTypes[i].lTypeId     = O_type_id;
        break;

      case SQL_NODATAFOUND:	/* no more data to read */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'doc_type'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "GetDocTables: SQL-Error for 'doc_type'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Cdoc_type;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Cdoc_type cursor ");
      sqlerror (rc, message);
    }
    else {
#ifdef _DEBUG_
      printf("Cdoc_type CLOSE\n");
#endif
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
    }
    fovdPrintLog (LOG_CUSTOMER, "Read DOC_TYPES table!\n");
  } /* if (rc == 0 && T_count != 0) ... */

  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading IMG_TYPE tables for document           */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

static int fnGetImgType(void) 
{
  int  rc = 0;
  int	i;
  
  pstImgTypes = NULL;

  /*
   * read the count for the entries of IMG_TYPES
   */
  
  fovdPrintLog (LOG_CUSTOMER, "Trying to get IMG_TYPES table\n");
  
  T_count = 0;
  
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM img_types;
  
  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "GetDocTables: Selected count(*) on IMG_TYPES failed.");
    sqlerror (rc, message);
  }
  

  fovdPrintLog (LOG_DEBUG,"GetDocTables: %d entries for IMG_TYPES\n", T_count);

  pstImgTypes = (stIMGTYPES *) malloc (sizeof (stIMGTYPES) * (T_count + 1));

  if (pstImgTypes == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"GetDocTables\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstImgTypes[T_count].lTypeId = -1;

  if ((rc == 0) && (T_count != 0)) {
    /*
     * read table IMG_TYPES from database
     */
    
    EXEC SQL OPEN   Cimg_type;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not open Cimg_type cursor ");
      sqlerror (rc, message);
    }
    else {
      rc = 0;
#ifdef _DEBUG_
      printf("Cimg_type OPEN status is OK\n");
#endif
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cimg_type INTO
        :O_type_id,
        :O_shdes,
        :O_copies;
      
      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        STRCPY_FROM_ORA (pstImgTypes[i].szShdes,   O_shdes);
        pstImgTypes[i].lTypeId    = O_type_id;
        pstImgTypes[i].lDefCopies = O_copies;
#ifdef _DEBUG_
        printf("pstImgTypes[%d]\tszShdes %s, lTypeId %d, lDefCopies %d\n", i, pstImgTypes[i].szShdes, O_type_id, O_copies); 
#endif
        break;

      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'img_type'");
        break;
        
       default:			/* some error */
         rc = ESQL_ERROR;
         count_attempt = 0;
         sqlerror (rc, "GetDocTables: SQL-Error for 'img_type'\n");
         break;
      }
    } /* of for .. */
    
    EXEC SQL CLOSE  Cimg_type;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Cimg_type cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
#ifdef _DEBUG_
      printf("Cimg_type CLOSE status is OK\n");
#endif
    }
    fovdPrintLog (LOG_CUSTOMER, "Read IMG_TYPES table!\n");
  }
  
  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading IMG_LNK_DOC tables for document        */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

static int fnGetImgLnk(void) {
  int  rc;
  int	i;

  pstImgLnk   = NULL;

  /*
   * read the count for the entries of IMG_LNK_DOC
   */
  fovdPrintLog (LOG_CUSTOMER, "Trying to get IMG_LNK_DOC table\n");

  T_count = 0;
   
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM img_lnk_doc;
  
  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "GetDocTables: Selected count(*) on IMG_LNK_DOC failed.");
    sqlerror (rc, message);
  }
   

  fovdPrintLog (LOG_DEBUG, "GetDocTables: %d entries for IMG_LNK_DOC\n", T_count);

  pstImgLnk = (stIMGLNKDOC *) malloc (sizeof (stIMGLNKDOC) * (T_count + 1));

  if (pstImgLnk == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"GetDocTables\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstImgLnk[T_count].lDocType = -1;

  if ((rc == 0) && (T_count != 0)) {
    /*
     * read table IMG_LNK_DOC database
     */
    
    EXEC SQL OPEN   Cimg_lnk;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not open Cimg_lnk cursor ");
      sqlerror (rc, message);
    }
    else {
      rc = 0;
#ifdef _DEBUG_
      printf("Cimg_lnk OPEN status is OK\n");
#endif
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cimg_lnk INTO
        :O_type_id,
        :O_itype_id;

      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstImgLnk[i].lDocType = O_type_id;
        pstImgLnk[i].lImgType = O_itype_id;
#ifdef _DEBUG_
        printf("pstImgLnk[%d]\tlDocType %d, lDefCopies %d\n", i, O_type_id, O_itype_id); 
#endif
        break;

      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'img_lnk_doc'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "GetDocTables: SQL-Error for 'img_lnk_doc'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Cimg_lnk;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Cimg_lnk cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
#ifdef _DEBUG_
      printf("Cimg_lnk CLOSE status is OK\n");
#endif
      
    }
    fovdPrintLog (LOG_CUSTOMER, "Read IMG_LNK_DOC table!\n");
  } /* of if (rc == 0) ... */

  return(rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading CUST_IMAGES tables for document        */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

static int fnGetCustImg(void) {
  int  rc;
  int	i;
  
  pstCustImg  = NULL;
  
  /*
   * read the count for the entries of CUST_IMAGES
   */
  fovdPrintLog (LOG_CUSTOMER, "Trying to get CUST_IMAGES table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM cust_images;
  
  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "GetDocTables: Selected count(*) on CUST_IMAGES failed.");
    sqlerror (rc, message);
  }

#ifdef _DEBUG_
  printf("GetDocTables: %d entries for CUST_IMAGES\n", T_count);
#endif
  fovdPrintLog (LOG_DEBUG, "GetDocTables: %d entries for CUST_IMAGES\n", T_count);

  pstCustImg = (stCUSTIMAGES *) malloc (sizeof (stCUSTIMAGES) * (T_count + 1));

  if (pstCustImg == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"GetDocTables\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstCustImg[T_count].lTypeId = -1;

  if ((rc == 0) && (T_count != 0)) {
    /*
     * read table CUST_IMAGES from database
     */

    EXEC SQL OPEN   Ccust_img;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not open Ccust_img cursor ");
      sqlerror (rc, message);
    }
    else {
      rc = 0;
    }

    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Ccust_img INTO
        :O_cust_id,
        :O_type_id,
        :O_copies;

      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstCustImg[i].lCustId = O_cust_id;
        pstCustImg[i].lTypeId = O_type_id;
        pstCustImg[i].lCopies = O_copies;
        break;

      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'cust_images'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "GetDocTables: SQL-Error for 'cust_images'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Ccust_img;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Ccust_img cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
#ifdef _DEBUG_
      printf("CUST_IMAGES CLOSE status is OK\n");
#endif
    }
    fovdPrintLog (LOG_CUSTOMER, "Read CUST_IMAGES table!\n");
  } /* if (rc == 0) ... */
  
  return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading IMAGE_TYPES_LEVEL tables for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

static int fnGetImgTypeLevel(void) {
  int  rc = 0;
  int	i;
  int	k;
  int	j;
  

  pstImgTypLevel=NULL;
 
  /*
   * read the count for the entries of IMG_TYPES_LEVEL
   */
  fovdPrintLog (LOG_CUSTOMER, "Trying to get IMG_TYPES_LEVEL table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM img_types_level;

  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "GetImgTypeLevel: Selected count(*) on IMG_TYPES_LEVEL (%s) failed.", O_db_name.arr);
    sqlerror (rc, message);
  }

  fovdPrintLog (LOG_DEBUG, "GetImgTypeLevel: %d entries for IMG_TYPES_LEVEL\n", T_count);

  pstImgTypLevel = (stIMGTYPESLV *) calloc (sizeof (stIMGTYPESLV), T_count + 1);

  if (pstImgTypLevel == NULL) {
    printf("NO MEMORY !!!!\n");
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"GetDocTables\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstImgTypLevel[T_count].lTypeId = -1;
  
  if ((rc == 0) && (T_count != 0)) {
    /*
     * read table IMG_TYPES_LEVEL from database
     */

    EXEC SQL OPEN   Cimg_type_level;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not open Cimg_type_level cursor ");
      sqlerror (rc, message);
    }
    else {
      rc = 0;
#ifdef _DEBUG_
      printf("IMG_TYPE_LEVEL OPEN status is OK\n");
#endif
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cimg_type_level INTO
        :O_type_id,
        :O_cslevel;
      
      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        STRCPY_FROM_ORA (pstImgTypLevel[i].szCslevel, O_cslevel);
        pstImgTypLevel[i].lTypeId = O_type_id;
#ifdef _DEBUG_
        printf("pstImgTypLevel[%d]\tlTypeId %d, szCsLevel %s\n", i, O_type_id, O_cslevel.arr);
#endif
        break;
        
      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'img_type_level'");
        break;
        
      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "GetDocTables: SQL-Error for 'img_type_level'\n");
        break;
      }
    } /* of for .. */
    
    EXEC SQL CLOSE  Cimg_type_level;
#ifdef _DEBUG_
      printf("IMG_TYPE_LEVEL CLOSE status is OK\n");
#endif

    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Cimg_type_level cursor");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
    }
    fovdPrintLog (LOG_CUSTOMER, "Read IMG_TYPES_LEVEL table!\n");
  } /* if (rc == 0 ..) */
  
  /* now fill the rest of table pstImgTypLevel */
  if (rc == 0) {
    for (i = 0; pstImgTypLevel[i].lTypeId != -1; i++) {
      k = 0;
      for (j = 0; pstImgLnk[j].lDocType != -1; j++) {
        if (pstImgLnk[j].lImgType == pstImgTypLevel[i].lTypeId) {
          if (k < TYPLAST) {
            pstImgTypLevel[i].aiDocTyp[k++] = pstImgLnk[j].lDocType;
          }

          if (pstImgLnk[j].lDocType == ITB_TYPE) {
            pstImgTypLevel[i].BchItb = 1;
          }
        } /* if (..ImgType == .. TypeId) */

        /* set end indicator */
        pstImgTypLevel[i].aiDocTyp[k] = -1;
      } /* for (.. ImgLnk ..) */

      /*
       * ensure that invoice comes first
       * not very pretty, but it works
       */
      if ((pstImgTypLevel[i].aiDocTyp[0] != -1) && (pstImgTypLevel[i].aiDocTyp[1] == 1)) {
        pstImgTypLevel[i].aiDocTyp[1] = pstImgTypLevel[i].aiDocTyp[0];
        pstImgTypLevel[i].aiDocTyp[0] = 1;
      }

      /* set the default copies */
      for (j = 0; pstImgTypes[j].lTypeId != -1; j++) {
        if (pstImgTypes[j].lTypeId == pstImgTypLevel[i].lTypeId) {
          pstImgTypLevel[i].lCopies = pstImgTypes[j].lDefCopies;
          break;
        }
      }
    } /* for (.. ImgTypeLevel.. ) */

    /* not needed any more */
    free (pstImgLnk);
    pstImgLnk = NULL;
  }
  
  return(rc);
}



/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPDPLTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

extern stVPLMN *pstVPLMN;
extern long lVPLMNCount;

int fnGetMpdplTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPDPLTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM mpdpltab;
  
  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "fnGetMpdplTab: Selected count(*) on MPDPLTAB failed.");
    sqlerror (rc, message);
  }

  lVPLMNCount = T_count;

  fovdPrintLog (LOG_DEBUG, "fnGetMpdplTab: %d entries for MPDPLTAB\n", T_count);

  pstVPLMN = (stVPLMN *) malloc (sizeof (stVPLMN) * (T_count + 1));
  
  if (pstVPLMN == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetMpdplTab\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstVPLMN[T_count].lIndex = -1;

  fovdPrintLog (LOG_DEBUG, "fnGetMpdpltab: Stating loading MPDPLTAB\n", T_count);  

  if ((rc == 0) && (T_count != 0)) {

    EXEC SQL OPEN Cvplmn;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetMpdplTab: Could not open Cvplmn cursor ");
      sqlerror (rc, message);
    }
    else {
      fovdPrintLog (LOG_DEBUG, "fnGetMpdplTab: Cusrsor Cvplmn for MPDPLTAB opened\n", T_count);  
      rc = 0;
    }

    /*
      typedef struct {
      char szShdes[7];
      char szPlmnName[13];
      char szCountry[21];
      } stVPLMN;
    */

    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cvplmn INTO
        :O_shdes,
        :O_plmnname,
        :O_country;
      
      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstVPLMN[i].lIndex = i;
        STRCPY_FROM_ORA (pstVPLMN[i].szShdes,   O_shdes);
        STRCPY_FROM_ORA (pstVPLMN[i].szPlmnName,   O_plmnname);
        STRCPY_FROM_ORA (pstVPLMN[i].szCountry,   O_country);
        fovdPrintLog (LOG_DEBUG, "fnGetMpdplTab: Read %s (%s) from %s\n", 
                      pstVPLMN[i].szPlmnName, pstVPLMN[i].szShdes, pstVPLMN[i].szCountry);  
        break;
        
      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "GetDocTables: no more data for 'mpdpltab'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "GetDocTables: SQL-Error for 'mpdpltab'\n");
        break;
      }
    } /* of for .. */
    
    EXEC SQL CLOSE  Cvplmn;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "GetDocTables: Could not close Cvplmn cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
      fovdPrintLog (LOG_DEBUG, "GetDocTables: Cusrsor Cvplmn for MPDPLTAB closed\n", T_count);  
    }
    fovdPrintLog (LOG_CUSTOMER, "Read MPDPLTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;

}

 
/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading DETINATION        table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

extern stDest *pstDest;

int fnGetDestTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get DESTINATION table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM DESTINATION;
  
  if (sqlca.sqlcode != 0) {
    rc = ESQL_SELCOUNT;
    count_attempt = 0;
    sprintf (message, "fnGetDestTab: Selected count(*) on DESTINATION failed.");
    sqlerror (rc, message);
  }

  fovdPrintLog (LOG_DEBUG, "fnGetDestTab: %d entries for DESTINATION\n", T_count);

  pstDest = (stDest*) malloc (sizeof (stDest) * (T_count + 1));

  if (pstDest == NULL) {
    macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetDestTab\"");
    return ((int) ESQL_ALLOC);
  }
  /* preset last element */
  pstDest[T_count].lIndex = -1;

  fovdPrintLog (LOG_DEBUG, "fnGetDestTab: Starting loading DESTINATION with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) {

    EXEC SQL OPEN Cdest;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetdestTab: Could not open Cdest cursor ");
      sqlerror (rc, message);
    }
    else {
      fovdPrintLog (LOG_DEBUG, "fnGetDestTab: Cusrsor Cdest for DESTINATION opened\n", T_count);  
      rc = 0;
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cdest INTO
        :O_prefix,
        :O_dest,
        :O_zone;

      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstDest[i].lIndex = i;
        STRCPY_FROM_ORA (pstDest[i].szPrefix,   O_prefix);
        STRCPY_FROM_ORA (pstDest[i].szDest,   O_dest);
        STRCPY_FROM_ORA (pstDest[i].szZone,   O_zone);        
        fovdPrintLog (LOG_DEBUG, "fnGetDestTab: Read %s from %s in %s\n", 
                      pstDest[i].szPrefix, pstDest[i].szDest, pstDest[i].szZone);  
        break;
        
      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetdestTab: no more data for 'DESTINATION'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "fnGetDestTab: SQL-Error for 'DESTINATION'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Cdest;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetDestTab: Could not close Cdest cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
      fovdPrintLog (LOG_DEBUG, "fnGetDestTab: Cusrsor Cdest for DESTINATION closed\n", T_count);  
    }
    fovdPrintLog (LOG_CUSTOMER, "Read DESTINATION table!\n");
  } /* if (rc == 0) ... */

  return rc;
}
 
/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUTZTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 
 
extern stTariffZone *pstTariffZone;
extern long glTZCount;

/*
typedef struct {

  long lIndex;
  long lTariffZoneCode;
  char szDes[31];
  char szShdes[6];

} stTariffZone;
*/

int fnGetTariffZoneTab()
{
  int  rc;
  int	i, j;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUZNTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUZNTAB;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetTariffZoneTab: Selected count(*) on MPUZNTAB failed.");
      sqlerror (rc, message);
    }

  fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: %d entries for MPUZNTAB\n", T_count);

  pstTariffZone = (stTariffZone*) malloc (sizeof (stTariffZone) * (T_count + 1));

  if (pstTariffZone == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetTariffZoneTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstTariffZone[T_count].lIndex = -1;
  glTZCount = T_count;

  fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: Starting loading MPUZNTAB with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) {

    EXEC SQL OPEN Ctzone;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetTariffZoneTab: Could not open Ctzone cursor ");
      sqlerror (rc, message);
    }
    else {
      fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: Cusrsor Ctzone for MPUZNTAB opened\n", T_count);  
      rc = 0;
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Ctzone INTO
        :O_tariff_zone_code,
        :O_des,
        :O_shdes;

      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstTariffZone[i].lIndex = i;
        pstTariffZone[i].lTariffZoneCode = O_tariff_zone_code;

        STRCPY_FROM_ORA (pstTariffZone[i].szDes, O_des);
        STRCPY_FROM_ORA (pstTariffZone[i].szShdes,   O_shdes);        
        fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: Read MPUZNTAB %d, %s, %s\n", 
                      pstTariffZone[i].lTariffZoneCode, pstTariffZone[i].szDes, pstTariffZone[i].szShdes);  
        break;
        
      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetTariffZoneTab: no more data for 'MPUZNTAB'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "fnGetTariffZoneTab: SQL-Error for 'MPUZNTAB'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Ctzone;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetTariffZoneTab: Could not close Ctzone cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
      fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: Cusrsor Ctzone for MPUZNTAB closed\n", T_count);  
    }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUZNTAB table!\n");
  } /* if (rc == 0) ... */

  /*
   * Check uniqueness of shdes attributes in TZ table
   * bIsKey = FALSE iff shdes may be a key (there is a single occurece of this string)
   */
  /*
  fovdPrintLog (LOG_CUSTOMER, "Checking MPUZNTAB table\n");
  for (i = 0; i < glTZCount; i++)
    {
      for (j = 0; j < glTZCount; j++)
        {
          if (!strcmp(pstTariffZone[i].szShdes, pstTariffZone[j].szShdes) && i != j)
            {
              pstTariffZone[i].enIsKey = FALSE;
              strcpy(pstTariffZone[i].szDes, pstTariffZone[i].szShdes);
              fovdPrintLog (LOG_DEBUG, "fnGetTariffZoneTab: Entry[%d] %s is not a key\n", 
                            i, pstTariffZone[i].szShdes);  
            }
        }
      if (j == glTZCount)
        {
          pstTariffZone[i].enIsKey = TRUE;
        }
    }
  fovdPrintLog (LOG_CUSTOMER, "Checking MPUZNTAB table finished!\n");
  */

  return rc;
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUTTTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

extern stTariffTime *pstTariffTime;
extern long glTTCount;

/*
typedef struct {
  long lIndex
  long lTariffTimeCode;
  char szDes[31];
  char szShdes[6];

} stTariffTime;
*/

int fnGetTariffTimeTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUTTTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUTTTAB;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetTariffTimeTab: Selected count(*) on MPUTTTAB failed.");
      sqlerror (rc, message);
    }

  fovdPrintLog (LOG_DEBUG, "fnGetTariffTimeTab: %d entries for MPUTTTAB\n", T_count);

  pstTariffTime = (stTariffTime*) malloc (sizeof (stTariffTime) * (T_count + 1));

  if (pstTariffTime == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetTariffTimeTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstTariffTime[T_count].lIndex = -1;
  glTTCount = T_count;
  
  fovdPrintLog (LOG_DEBUG, "fnGetTariffTimeTab: Starting loading MPUTTTAB with %d entries\n", T_count);  
  
  if ((rc == 0) && (T_count != 0)) {

    EXEC SQL OPEN Cttime;

    if (sqlca.sqlcode != 0) {
      rc = ESQL_OPENTESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetTariffTimeTab: Could not open Cttime cursor ");
      sqlerror (rc, message);
    }
    else {
      fovdPrintLog (LOG_DEBUG, "fnGetTariffTimeTab: Cursor Cttime for MPUTTTAB opened\n", T_count);  
      rc = 0;
    }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) {
      EXEC SQL FETCH Cttime INTO
        :O_tariff_time_code,
        :O_des,
        :O_shdes;

      
      switch (sqlca.sqlcode) {
      case 0:			/* succesful read entry */
        pstTariffTime[i].lIndex = i;
        pstTariffTime[i].lTariffTimeCode = O_tariff_time_code;
        STRCPY_FROM_ORA (pstTariffTime[i].szDes,   O_des);
        STRCPY_FROM_ORA (pstTariffTime[i].szShdes,   O_shdes);
        fovdPrintLog (LOG_DEBUG, "fnGetTariffTimeTab: Read MPUTTTAB %d, %s, %s\n", 
                      pstTariffTime[i].lTariffTimeCode, pstTariffTime[i].szDes, pstTariffTime[i].szShdes);  
        break;
        
      case SQL_NODATAFOUND:	/* read whole table */
        rc = ESQL_NOMOREDATA;
        macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetTariffTimeTab: no more data for 'MPUTTTAB'");
        break;

      default:			/* some error */
        rc = ESQL_ERROR;
        count_attempt = 0;
        sqlerror (rc, "fnGetTariffTimeTab: SQL-Error for 'MPUTTTAB'\n");
        break;
      }
    } /* of for .. */

    EXEC SQL CLOSE  Cttime;
    if (sqlca.sqlcode != 0) {
      rc = ESQL_CLOSETESTCURSOR;
      count_attempt = 0;
      sprintf (message, "fnGetTariffTimeTab: Could not close Cttime cursor ");
      sqlerror (rc, message);
    }
    else {
      EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
      fovdPrintLog (LOG_DEBUG, "fnGetTariffTimeTab: Cusrsor Cttime for MPUTTTAB closed\n", T_count);  
    }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUTTTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;
}


 
/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUSNTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 


/*
typedef struct {
  int iIndex;
  long lServiceCode;
  char szDes[31];
  char szShdes[6];
} stServiceName;
*/

extern stServiceName *pstServiceName;
extern long glSNCount;



int fnGetServiceNameTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUSNTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUSNTAB;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetServiceNameTab: Selected count(*) on MPUSNTAB failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetServiceNameTab: %d entries for MPUSNTAB\n", T_count);
  
  pstServiceName = (stServiceName *) malloc (sizeof (stServiceName) * (T_count + 1));
  
  if (pstServiceName == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetServiceNameTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstServiceName[T_count].lIndex = -1;
  glSNCount = T_count;

  fovdPrintLog (LOG_DEBUG, "fnGetServiceNameTab: Starting loading MPUSNTAB with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Csname;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetServiceNameTab: Could not open Csname cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetServiceNameTab: Cursor Csname for MPUSNTAB opened\n", T_count);  
          rc = 0;
        }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) 
      {
        EXEC SQL FETCH Csname INTO
          :O_service_name_code,
          :O_des,
          :O_shdes;
        
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */
            pstServiceName[i].lIndex = i;
            pstServiceName[i].lServiceNameCode = O_service_name_code;
            STRCPY_FROM_ORA (pstServiceName[i].szDes, O_des);
            STRCPY_FROM_ORA (pstServiceName[i].szShdes, O_shdes);
            fovdPrintLog (LOG_DEBUG, "fnGetServiceNameTab: Read MPUSNTAB %d, %s, %s\n", 
                          pstServiceName[i].lServiceNameCode, pstServiceName[i].szDes, pstServiceName[i].szShdes);  
            break;
        
          case SQL_NODATAFOUND:	/* read whole table */
            rc = ESQL_NOMOREDATA;
            macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetServiceNameTab: no more data for 'MPUSNTAB'");
            break;

          default:			/* some error */
            rc = ESQL_ERROR;
            count_attempt = 0;
            sqlerror (rc, "fnGetServiceNameTab: SQL-Error for 'MPUSNTAB'\n");
            break;
          }
      } /* of for .. */
    
    EXEC SQL CLOSE  Csname;
    if (sqlca.sqlcode != 0) 
      {
        rc = ESQL_CLOSETESTCURSOR;
        count_attempt = 0;
        sprintf (message, "fnGetServiceNameTab: Could not close Csname cursor ");
        sqlerror (rc, message);
      }
    else 
      {
        EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
        fovdPrintLog (LOG_DEBUG, "fnGetServiceNameTab: Cursor Csname for MPUSNTAB closed\n", T_count);  
      }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUSNTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;
}
 
/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUTMTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

/*
typedef struct {
  int lIndex;
  long lTariffModelCode;
  char szDes[31];
  char szShdes[6];
} stTariffmodel;
*/

extern stTariffModel *pstTariffModel;
extern long glTMCount;

int fnGetTariffModelTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUTMTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUTMTAB
    WHERE STATUS = 'P';
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetTariffModelTab: Selected count(*) on MPUTMTAB failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetTariffModelTab: %d entries for MPUTMTAB\n", T_count);
  
  pstTariffModel = (stTariffModel *) malloc (sizeof (stTariffModel) * (T_count + 1));
  
  if (pstTariffModel == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetTariffModelTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstTariffModel[T_count].lIndex = -1;
  glTMCount = T_count;

  fovdPrintLog (LOG_DEBUG, "fnGetTariffModelTab: Starting loading MPUTMTAB with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Ctmodel;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetTariffModelTab: Could not open Ctmodel cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetTariffModelTab: Cursor Csname for MPUTMTAB opened\n", T_count);  
          rc = 0;
        }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) 
      {
        EXEC SQL FETCH Ctmodel INTO
          :O_tariff_model_code,
          :O_tariff_model_version,
          :O_des,
          :O_shdes;
        
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */
            pstTariffModel[i].lIndex = i;
            pstTariffModel[i].lTariffModelCode = O_tariff_model_code;
            pstTariffModel[i].lTariffModelVersion = O_tariff_model_version;
            STRCPY_FROM_ORA (pstTariffModel[i].szDes, O_des);
            STRCPY_FROM_ORA (pstTariffModel[i].szShdes, O_shdes);
            fovdPrintLog (LOG_DEBUG, "fnGetTariffModelTab: Read MPUTMTAB %d, %s, %s\n", 
                          pstTariffModel[i].lTariffModelCode, pstTariffModel[i].szDes, pstTariffModel[i].szShdes);  
            break;
        
          case SQL_NODATAFOUND:	/* read whole table */
            rc = ESQL_NOMOREDATA;
            macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetTariffModelTab: no more data for 'MPUTMTAB'");
            break;

          default:			/* some error */
            rc = ESQL_ERROR;
            count_attempt = 0;
            sqlerror (rc, "fnGetTariffModelTab: SQL-Error for 'MPUTMTAB'\n");
            break;
          }
      } /* of for .. */
    
    EXEC SQL CLOSE  Ctmodel;
    if (sqlca.sqlcode != 0) 
      {
        rc = ESQL_CLOSETESTCURSOR;
        count_attempt = 0;
        sprintf (message, "fnGetTariffModelTab: Could not close Ctmodel cursor ");
        sqlerror (rc, message);
      }
    else 
      {
        EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
        fovdPrintLog (LOG_DEBUG, "fnGetTariffmodelTab: Cursor Ctnmae for MPUTMTAB closed\n", T_count);  
      }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUTMTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUSPTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

/*
typedef struct {
  int lIndex;
  long lServicePackageCode;
  char szDes[31];
  char szShdes[6];
} stServicePackage;
*/

extern stServicePackage *pstServicePackage;
extern long glSPCount;

int fnGetSPTab()
{
  int  rc;
  int	i;
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUSPTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUSPTAB;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetSPTab: Selected count(*) on MPUSPTAB failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetSPTab: %d entries for MPUSPTAB\n", T_count);
  
  pstServicePackage = (stServicePackage *) malloc (sizeof (stServicePackage) * (T_count + 1));
  
  if (pstServicePackage == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetSPTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstServicePackage[T_count].lIndex = -1;
  glSPCount = T_count;

  fovdPrintLog (LOG_DEBUG, "fnGetSPTab: Starting loading MPUSPTAB with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cspackage;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetSPTab: Could not open Cspackage cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetSPTab: Cursor Cspackage for MPUSPTAB opened\n", T_count);  
          rc = 0;
        }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) 
      {
        EXEC SQL FETCH Cspackage INTO
          :O_service_package_code,
          :O_des,
          :O_shdes;
        
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */
            pstServicePackage[i].lIndex = i;
            pstServicePackage[i].lServicePackageCode = O_service_package_code;
            STRCPY_FROM_ORA (pstServicePackage[i].szDes, O_des);
            STRCPY_FROM_ORA (pstServicePackage[i].szShdes, O_shdes);
            fovdPrintLog (LOG_DEBUG, "fnGetServicePackageTab: Read MPUSPTAB %d, %s, %s\n", 
                          pstServicePackage[i].lServicePackageCode, 
                          pstServicePackage[i].szDes, pstServicePackage[i].szShdes);  
            break;
        
          case SQL_NODATAFOUND:	/* read whole table */
            rc = ESQL_NOMOREDATA;
            macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetSPTab: no more data for 'MPUSPTAB'");
            break;

          default:			/* some error */
            rc = ESQL_ERROR;
            count_attempt = 0;
            sqlerror (rc, "fnGetSPTab: SQL-Error for 'MPUSPTAB'\n");
            break;
          }
      } /* of for .. */
    
    EXEC SQL CLOSE  Cspackage;
    if (sqlca.sqlcode != 0) 
      {
        rc = ESQL_CLOSETESTCURSOR;
        count_attempt = 0;
        sprintf (message, "fnGetSPTab: Could not close Cspackage cursor ");
        sqlerror (rc, message);
      }
    else 
      {
        EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
        fovdPrintLog (LOG_DEBUG, "fnGetSPTab: Cursor Cspackage for MPUSPTAB closed\n", T_count);  
      }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUSPTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPUPNTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

/*
typedef struct {
  int lIndex;
  char szDigits[19];
} stPN;
*/

extern stPN *pstPN;
extern long glPNCount;

int fnGetPNTab()
{
  int  rc;
  int	i;
  char lachzDigits[19];
  
  rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPUPNTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM MPUPNTAB;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetPNTab: Selected count(*) on MPUPNTAB failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetPNTab: %d entries for MPUPNTAB\n", T_count);
  pstPN = (stPN *) malloc (sizeof (stPN) * (T_count + 1));
  if (pstPN == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetPNTab\"");
      return ((int) ESQL_ALLOC);
    }
  /* preset last element */
  pstPN[T_count].lIndex = -1;
  glPNCount = T_count;
  fovdPrintLog (LOG_DEBUG, "fnGetPNTab: Starting loading MPUPNTAB with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cpn;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetPNTab: Could not open Cpn cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetPNTab: Cursor Cpn for MPUPNTAB opened\n", T_count);  
          rc = 0;
        }
    
    for (i = 0; (i < T_count) && (rc == 0); i++) 
      {
        EXEC SQL FETCH Cpn INTO
          :O_digits;
        
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */
            pstPN[i].lIndex = i;
            STRCPY_FROM_ORA (lachzDigits, O_digits);
            
            /*
             * Number in normal format : +48xxxxxxxxx
             */
            
            strncpy(pstPN[i].szDigits, lachzDigits + 3, 18);
            fovdPrintLog (LOG_DEBUG, "fnGetPNTab: Read MPUPNTAB : %s -> %s\n", lachzDigits, pstPN[i].szDigits);
            break;
        
          case SQL_NODATAFOUND:	/* read whole table */
            rc = ESQL_NOMOREDATA;
            macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetPNTab: no more data for 'MPUPNTAB'");
            break;

          default:			/* some error */
            rc = ESQL_ERROR;
            count_attempt = 0;
            sqlerror (rc, "fnGetPNTab: SQL-Error for 'MPUPNTAB'\n");
            break;
          }
      } /* of for .. */
    
    EXEC SQL CLOSE  Cpn;
    if (sqlca.sqlcode != 0) 
      {
        rc = ESQL_CLOSETESTCURSOR;
        count_attempt = 0;
        sprintf (message, "fnGetPNTab: Could not close Cpn cursor ");
        sqlerror (rc, message);
      }
    else 
      {
        EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */
        fovdPrintLog (LOG_DEBUG, "fnGetPNTab: Cursor Cpn for MPUPNTAB closed\n", T_count);  
      }
    fovdPrintLog (LOG_CUSTOMER, "Read MPUPNTAB table!\n");
  } /* if (rc == 0) ... */

  return rc;
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading PRICEGROUP_ALL    table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 


/*
#define PRICEGROUP_CODE_SIZE 16
#define PRICEGROUP_NAME_SIZE 32

typedef struct
{
  char sasnzCode[PRICEGROUP_CODE_SIZE];
  long soilSeqNo;
  char sasnzName[PRICEGROUP_NAME_SIZE];
  
} tostPriceGroup;
*/

extern tostPriceGroup *gpstPriceGroup;
extern long goilPriceGroupSize;

int fnGetPriceGroup()
{
  int i, rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get PRICEGROUP_ALL table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM PRICEGROUP_ALL;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetPriceGroup: Selected count(*) on PRICEGROUP_ALL failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetPriceGroup: %d entries for PRICEGROUP_ALL\n", T_count);
  gpstPriceGroup = (tostPriceGroup *) malloc (sizeof (tostPriceGroup) * (T_count + 1));
  if (gpstPriceGroup == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetPriceGroup\"");
      return ((int) ESQL_ALLOC);
    }

  gpstPriceGroup[T_count].soilIndex = -1;
  goilPriceGroupSize = T_count;
  fovdPrintLog (LOG_DEBUG, "fnGetPriceGroup: Starting loading PRICEGROUP_ALL with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cprice_group;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetPriceGroup: Could not open Cprice_group cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetPriceGroup: Cursor Cprice_group for PRICEGROUP_ALL opened\n", T_count);  
          rc = 0;
        }
    
      for (i = 0; (i < T_count) && (rc == 0); i++) 
        {
          EXEC SQL FETCH Cprice_group INTO
            :Oprice_group_code,
            :Oprice_group_seq_no,
            :Oprice_group_name;
        
          switch (sqlca.sqlcode) 
            {
            case 0:
              gpstPriceGroup[i].soilIndex = i;
              STRCPY_FROM_ORA (gpstPriceGroup[i].sasnzCode, Oprice_group_code);
              gpstPriceGroup[i].soilSeqNo = Oprice_group_seq_no;
              STRCPY_FROM_ORA(gpstPriceGroup[i].sasnzName, Oprice_group_name);              
              fovdPrintLog (LOG_DEBUG, "fnGetPriceGroup: Read MPUPNTAB\n");
              break;
              
            case SQL_NODATAFOUND:
              rc = ESQL_NOMOREDATA;
              macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetPriceGroup: no more data for 'PRICEGROUP_ALL'");
              break;
              
            default:		
              rc = ESQL_ERROR;
              count_attempt = 0;
              sqlerror (rc, "fnGetPriceGroup: SQL-Error for 'PRICEGROUP_ALL'\n");
              break;
            }
        }
      
      EXEC SQL CLOSE  Cprice_group;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetPriceGroup: Could not close Cprice_group cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes);
          fovdPrintLog (LOG_DEBUG, "fnGetPriceGroup: Cursor Cprice_group for PRICEGROUP_ALL closed\n");  
        }

      fovdPrintLog (LOG_CUSTOMER, "Read PRICEGROUP_ALL table!\n");
    } 

  return rc;
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading PAYMENTTYPE_ALL   table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

extern int goilPaymentTypeSize;
extern tostPaymentType *gpstPaymentType;

int fnGetPaymentType()
{
  int i, rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get PAYMENTTYPE_ALL table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM PAYMENTTYPE_ALL;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetPaymentType: Selected count(*) on PAYMENTTYPE_ALL failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetPaymentType: %d entries for PAYMENTTYPE_ALL\n", T_count);
  gpstPaymentType = (tostPaymentType *) malloc (sizeof (tostPaymentType) * (T_count + 1));
  if (gpstPaymentType == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetPaymentType\"");
      return ((int) ESQL_ALLOC);
    }

  gpstPaymentType[T_count].soilIndex = -1;
  goilPaymentTypeSize = T_count;
  fovdPrintLog (LOG_DEBUG, "fnGetPaymentType: Starting loading PAYMENTTYPE_ALL with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cpayment_type;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetPaymentType: Could not open Cpayment_type cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetPaymentType: Cursor Cpayment_type for PAYMENTTYPE_ALL opened\n", T_count);  
          rc = 0;
        }
    
      for (i = 0; (i < T_count) && (rc == 0); i++) 
        {
          EXEC SQL FETCH Cpayment_type INTO
            :Opayment_type_id,
            :Opayment_type_code,
            :Opayment_type_name;
        
          switch (sqlca.sqlcode) 
            {
            case 0:
              gpstPaymentType[i].soilIndex = i;
              gpstPaymentType[i].soiPaymentId = Opayment_type_id;
              gpstPaymentType[i].sochPaymentCode = Opayment_type_code;
              STRCPY_FROM_ORA (gpstPaymentType[i].sasnzPaymentName, Opayment_type_name);
              fovdPrintLog (LOG_DEBUG, "fnGetPaymentType: Read PAYMENTTYPE_ALL\n");
              break;
              
            case SQL_NODATAFOUND:
              rc = ESQL_NOMOREDATA;
              macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetPaymentType: no more data for 'PAYMENTTYPE_ALL'");
              break;
              
            default:		
              rc = ESQL_ERROR;
              count_attempt = 0;
              sqlerror (rc, "fnGetPaymentType: SQL-Error for 'PAYMENTTYPE_ALL'\n");
              break;
            }
        }
      
      EXEC SQL CLOSE  Cpayment_type;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetPaymentType: Could not close Cpayment_type cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes);
          fovdPrintLog (LOG_DEBUG, "fnGetPaymentType: Cursor Cpayment_type for PAYMENTTYPE_ALL closed\n");  
        }

      fovdPrintLog (LOG_CUSTOMER, "Read PAYMENTTYPE_ALL table!\n");
    } 

  return rc;
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading BILL_MDEIUM       table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 

int goilBillMediumSize = 0;
tostBillMedium *gpstBillMedium = NULL;

int fnGetBillMedium()
{
  int i, rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get BILL_MEDIUM table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
    SELECT count(*)
    INTO :T_count
    FROM BILL_MEDIUM;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetBillMedium: Selected count(*) on BILL_MEDIUM failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetBillMedium: %d entries for BILL_MEDIUM\n", T_count);
  gpstBillMedium = (tostBillMedium *) calloc (T_count + 1, sizeof (tostBillMedium));
  if (gpstBillMedium == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetBillMedium\"");
      return ((int) ESQL_ALLOC);
    }

  gpstBillMedium[T_count].soilIndex = -1;
  goilBillMediumSize = T_count;
  fovdPrintLog (LOG_DEBUG, "fnGetBillMedium: Starting loading BILL_MEDIUM with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cbill_medium;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetBillMedium: Could not open Cbill_medium cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetBillMedium: Cursor Cbill_medium for BILL_MEDIUM opened\n", T_count);  
          rc = 0;
        }
    
      for (i = 0; (i < T_count) && (rc == 0); i++) 
        {
          EXEC SQL FETCH Cbill_medium INTO
            :Obill_medium_id:Obill_medium_id_ind,
            :Obill_medium_des:Obill_medium_des_ind,
            :Obill_medium_default:Obill_medium_default_ind;
          
          switch (sqlca.sqlcode) 
            {
            case 0:
              gpstBillMedium[i].soilIndex = i;
              gpstBillMedium[i].soiId = Obill_medium_id;              
              STRCPY_FROM_ORA (gpstBillMedium[i].sasnzDes, Obill_medium_des);
              if (Obill_medium_default_ind != -1)
                {
                  STRCPY_FROM_ORA (gpstBillMedium[i].sasnzDefault, Obill_medium_default);
                }
              fovdPrintLog (LOG_DEBUG, "fnGetBillMedium: Read BILL_MEDIUM: %02d %02d %s %s\n",
                            gpstBillMedium[i].soilIndex,
                            gpstBillMedium[i].soiId,
                            gpstBillMedium[i].sasnzDes,
                            gpstBillMedium[i].sasnzDefault);
              break;
              
            case SQL_NODATAFOUND:
              rc = ESQL_NOMOREDATA;
              macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetBillMedium: no more data for 'BILL_MEDIUM'");
              break;
              
            default:		
              rc = ESQL_ERROR;
              count_attempt = 0;
              sqlerror (rc, "fnGetBillMedium: SQL-Error for 'BILL_MEDIUM'\n");
              break;
            }
        }
      
      EXEC SQL CLOSE  Cbill_medium;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetBillMedium: Could not close Cbill_medium cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes);
          fovdPrintLog (LOG_DEBUG, "fnGetBillMedium: Cursor Cbill_medium for BILL_MEDIUM closed\n");  
        }

      fovdPrintLog (LOG_CUSTOMER, "Read BILL_MEDIUM table!\n");
    } 

  return rc;
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading MPDSCTAB          table  for document  */
/*            generation from databases                      */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory.                                                   */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/ 


int goiMarketTabSize = 0;
tostMarket *gpstMarket = NULL;

int fnGetMarket()
{
  int i, rc = 0;

  fovdPrintLog (LOG_CUSTOMER, "Trying to get MPDSCTAB table\n");

  T_count = 0;
  EXEC SQL AT :O_db_name
     SELECT COUNT(*)
       INTO :T_count
       FROM MPDPLTAB PL,
            MPDSCTAB SC
      WHERE PL.PLMNTYPE = 'H'
        AND PL.SCCODE = SC.SCCODE;
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      count_attempt = 0;
      sprintf (message, "fnGetMarket: Selected count(*) on MPDSCTAB failed.");
      sqlerror (rc, message);
    }
  
  fovdPrintLog (LOG_DEBUG, "fnGetMarket: %d entries for MPDSCTAB\n", T_count);
  gpstMarket = (tostMarket *) malloc (sizeof (tostMarket) * (T_count + 1));
  if (gpstMarket == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"fnGetMarket\"");
      return ((int) ESQL_ALLOC);
    }

  gpstMarket[T_count].soiIndex = -1;
  goiMarketTabSize = T_count;
  fovdPrintLog (LOG_DEBUG, "fnGetMarket: Starting loading MARKET with %d entries\n", T_count);  

  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Cmarket;

      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetMarket: Could not open Cmarket cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          fovdPrintLog (LOG_DEBUG, "fnGetMarket: Cursor Cmarket for MPDSCTAB opened\n", T_count);  
          rc = 0;
        }
    
      for (i = 0; (i < T_count) && (rc == 0); i++) 
        {
          EXEC SQL FETCH Cmarket INTO
            :Omarket_id:Omarket_id_ind,
            :Oplmn_id:Oplmn_id_ind,
            :Omarket_des:Omarket_des_ind,
            :Onetwork_des:Onetwork_des_ind;
                      
          switch (sqlca.sqlcode) 
            {
            case 0:
              gpstMarket[i].soiIndex = i;
              gpstMarket[i].soiPLMNId = Oplmn_id;              
              gpstMarket[i].soiMarketId = Omarket_id;              
              STRCPY_FROM_ORA (gpstMarket[i].sasnzMarketDes, Omarket_des);
              STRCPY_FROM_ORA (gpstMarket[i].soszNetworkName, Onetwork_des);
              fovdPrintLog (LOG_DEBUG, "fnGetMarket: Read MPDSCTAB: %d, %d, %s, %s\n", 
                            gpstMarket[i].soiPLMNId, 
                            gpstMarket[i].soiMarketId, 
                            gpstMarket[i].sasnzMarketDes,
                            gpstMarket[i].soszNetworkName);
              
              break;
              
            case SQL_NODATAFOUND:
              rc = ESQL_NOMOREDATA;
              macErrorMessage (ESQL_NOMOREDATA, WARNING, "fnGetMarket: no more data for 'MPDSCTAB'");
              break;
              
            default:		
              rc = ESQL_ERROR;
              count_attempt = 0;
              sqlerror (rc, "fnGetMarket: SQL-Error for 'MPDSCTAB'\n");
              break;
            }
        }
      
      EXEC SQL CLOSE  Cmarket;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;
          count_attempt = 0;
          sprintf (message, "fnGetMarket: Could not close Cmarket cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes);
          fovdPrintLog (LOG_DEBUG, "fnGetMarket: Cursor Cbill_medium for MPDSCTAB closed\n");  
        }

      fovdPrintLog (LOG_CUSTOMER, "Read MPDSCTAB table!\n");
    } 

  return rc;
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading BSCS4 tables for document generation   */
/*            from databases                                 */
/*                                                           */
/* DESCRIPTION :                                             */
/* First reads, how may entries exist, then allocates memory */
/* for the entries and reads the entries into allocated      */
/* memory. This is done for each of the DBs.                 */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/

int GetDocTables (void)
{
   int  rc;
   rc  = 0;

   rc = fnGetDocType();

   if (rc == 0)
     {
       rc = GetBRECodeFromDatabase();
     }

     {
       rc = GetItbTaxRateFromDatabase();
     }

   if (rc == 0)
     {
       rc = fnGetMarket();
     }

   if (rc == 0)
     {
       rc = fnGetBillMedium();
     }

   if (rc == 0)
     {
       rc = fnGetPriceGroup();
     }

   if (rc == 0)
     {
       rc = fnGetPaymentType();
     }

   if (rc == 0)
     {
       rc = fnGetPNTab();
     }

   if (rc == 0) 
     {
       rc = fnGetMpdplTab();
     }
   
   if (rc == 0)
     {
       rc = fnGetServiceNameTab();
     }
   
   if (rc == 0)
     {
       rc = fnGetTariffZoneTab();
     }
   
   if (rc == 0)
     {
       rc = fnGetTariffTimeTab();
     }

   if (rc == 0)
     {
       rc = fnGetTariffModelTab();
     }
   
   if (rc == 0)
     {
       rc = fnGetSPTab();
     }

   if (rc == 0) 
     {
       rc = fnGetImgType();
     } 

   if (rc == 0) 
     {
       rc = fnGetImgLnk();
     } 

   if (rc == 0) 
     {
       rc = fnGetCustImg();
     } 

   if (rc == 0) 
     {
       rc = fnGetImgTypeLevel();
     } 

   if (rc == 0)
     {
       EXEC SQL AT  :O_db_name
	 SELECT MAX(DOCUMENT_SIZE)
	 INTO :DEFAULT_BLOB_SIZE
	 FROM DOCUMENT_ALL;
       
       if(sqlca.sqlcode != 0)
         {
           rc = ESQL_SELBASEDIR;
           sprintf(message, "GetDocTables: SQL-Error");
           sqlerror(rc, message);	   
         }       
       else
         {
           printf("%d\n", DEFAULT_BLOB_SIZE);
           fflush(stdout);
         }
     }

   return (rc);
} /* end GetDocTables subroutine */
#endif

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading header file path of BGH from table     */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELBASEDIR      : selecting base-directory           */
/* ESQL_NULLBASEDIR     : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/
int GetHeaderPathFromDatabase(void)
{
   int rc;
   char *doc;

   rc  = 0;

   switch (stBgh.enTimmProcessing)
     {
     case INV_TYPE:
     case ENC_TYPE:
       switch (stBgh.enOutputType)
         {
         case TEX:
           B_cfcode = TEX_HEADER_INV_CFCODE;
           break;
         case XGF:
           B_cfcode = XGF_HEADER_INV_CFCODE;
           break;
         }
       doc = "INV";
       break;
       
     case ITB_TYPE:
       switch (stBgh.enOutputType)
         {
         case TEX:
           B_cfcode = TEX_HEADER_ITB_CFCODE;
           break;
         case XGF:
           B_cfcode = XGF_HEADER_ITB_CFCODE;
           break;
         }
       doc = "ITB";
       break;
       
     case DNL_DWH:
       switch (stBgh.enOutputType)
         {
         case TEX:
           B_cfcode = TEX_HEADER_DNL_CFCODE;
           break;
         case XGF:
           B_cfcode = XGF_HEADER_DNL_CFCODE;
           break;
         }
       doc = "DNL";
       break;

     case WLL_DWH:
       switch (stBgh.enOutputType)
         {
         case TEX:
           B_cfcode = TEX_HEADER_WLL_CFCODE;
           break;
         case XGF:
           B_cfcode = XGF_HEADER_WLL_CFCODE;
           break;
         }
       doc = "WLL";
       break;

     case INH_INP:
     case INH_INL:
       switch (stBgh.enOutputType)
         {
         case TEX:
           B_cfcode = TEX_HEADER_INH_CFCODE;
           break;
         case XGF:
           B_cfcode = XGF_HEADER_INH_CFCODE;
           break;
         }
       doc = "INL";
       break;

     default:
       doc = "xxx";
       break;
     }

   fovdPrintLog (LOG_DEBUG, "Trying to get BGH header file for (TYPEID %d) %s with CFCODE %d\n", stBgh.enTimmProcessing, doc, B_cfcode);

   EXEC SQL AT  :O_db_name
     SELECT  cfvalue
     INTO  :B_cfvalue INDICATOR :B_cfvalue_ind
     FROM  mpscftab
     WHERE  cfcode = :B_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELBASEDIR;
           count_attempt = 0;
           sprintf(message, "GetHeaderPathFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           sprintf(message, "GetHeaderPathFromDatabase: header path for %s document in table mpscftab not found", doc);
           sqlerror(rc, message);
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if( B_cfvalue_ind < 0)
         {
           rc = ESQL_NULLBASEDIR;
           fovdPrintLog (LOG_NORMAL, "GetHeaderPathFromDatabase: NULL in database for header path detected\n");
         }
       else
         {
           STRCPY_FROM_ORA(stBgh.szHeaderPath, B_cfvalue);
           /* structure stBGHGLOB                    */
           fovdPrintLog (LOG_DEBUG,"GetHeaderPathFromDatabase: file name %s is successfully read for %s.\n", stBgh.szHeaderPath, doc);
         }
     }
   
   return (rc);
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading header file path of BGH from table     */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELBASEDIR      : selecting base-directory           */
/* ESQL_NULLBASEDIR     : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/
int GetBRECodeFromDatabase(void)
{
   int rc;
   char *doc;

   rc  = 0;

   stBgh.szBRECode[0] = '\0';
   B_cfcode = BRE_ID_CFCODE;
   fovdPrintLog (LOG_DEBUG, "Trying to get BRE code file for CFCODE %d\n", B_cfcode);

   EXEC SQL AT  :O_db_name
     SELECT  cfvalue
     INTO  :B_cfvalue INDICATOR :B_cfvalue_ind
     FROM  mpscftab
     WHERE  cfcode = :B_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELBASEDIR;
           count_attempt = 0;
           sprintf(message, "GetBRECodeFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           sprintf(message, "GetBRECodeFromDatabase: BRE code not found in database\n");
           sqlerror(rc, message);
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if( B_cfvalue_ind < 0)
         {
           rc = ESQL_NULLBASEDIR;
           fovdPrintLog (LOG_NORMAL, "GetBRECodeFromDatabase: NULL in database for BRE code detected\n");
         }
       else
         {
           STRCPY_FROM_ORA(stBgh.szBRECode, B_cfvalue);
           /* structure stBGHGLOB                    */
           fovdPrintLog (LOG_DEBUG,"GetBRECodeFromDatabase: BRE code is %s\n", stBgh.szBRECode);
         }
     }
   
   return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading header file path of BGH from table     */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELBASEDIR      : selecting base-directory           */
/* ESQL_NULLBASEDIR     : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/
int GetItbTaxRateFromDatabase(void)
{
   int rc;
   char *doc;
   char lasnzStr[128];

   rc  = 0;
   
   B_cfcode = ITB_TAX_RATE_CFCODE;
   fovdPrintLog (LOG_DEBUG, "Trying to get ITB tax rate file for CFCODE %d\n", B_cfcode);

   EXEC SQL AT  :O_db_name
     SELECT  cfvalue
     INTO  :B_cfvalue INDICATOR :B_cfvalue_ind
     FROM  mpscftab
     WHERE  cfcode = :B_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELBASEDIR;
           count_attempt = 0;
           sprintf(message, "GetItbTaxRateFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           sprintf(message, "GetItbTaxRateFromDatabase: Itb tax rate not found in database\n");
           sqlerror(rc, message);
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if( B_cfvalue_ind < 0)
         {
           rc = ESQL_NULLBASEDIR;
           fovdPrintLog (LOG_NORMAL, "GetItbTaxRateFromDatabase: NULL in database for Itb tax rate detected\n");
         }
       else
         {
           STRCPY_FROM_ORA(lasnzStr, B_cfvalue);
           sscanf(lasnzStr, "%lf", &(stBgh.soflItbTaxRate));                   
           fovdPrintLog (LOG_DEBUG,"GetItbTaxRateFromDatabase: Itb Tax Rate is %lf\n", stBgh.soflItbTaxRate);
         }
     }
   
   return (rc);
}

/*************************************************************/
/*                                                           */
/* ABSTRACT : Reading header file path of BGH from table     */
/*            mpscftab                                       */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/* ESQL_SELBASEDIR      : selecting base-directory           */
/* ESQL_NULLBASEDIR     : NULL detected                      */
/* ESQL_NOMOREDATA      : no more data                       */
/*                                                           */
/*************************************************************/
char *GetArgsFromDatabase(void)
{
   int rc;
   static char lachzArgs[512];

   rc  = 0;

   B_cfcode = ARGS_CFCODE;
   fovdPrintLog (LOG_DEBUG, "Trying to get ARGS from MPSCFTAB with CFCODE %d\n", B_cfcode);

   EXEC SQL AT  :O_db_name
     SELECT  cfvalue
     INTO  :B_cfvalue INDICATOR :B_cfvalue_ind
     FROM  mpscftab
     WHERE  cfcode = :B_cfcode;
   
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELBASEDIR;
           count_attempt = 0;
           sprintf(message, "GetArgsFromDatabase: SQL-Error");
           sqlerror(rc, message);
           lachzArgs[0] = '\0';
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           sprintf(message, "GetArgsFromDatabase: Args not found in database\n");
           sqlerror(rc, message);
           lachzArgs[0] = '\0';
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if(B_cfvalue_ind < 0)
         {
           rc = ESQL_NULLBASEDIR;
           fovdPrintLog (LOG_NORMAL, "GetArgsFromDatabase: NULL in database for args detected\n");
           lachzArgs[0] = '\0';
         }
       else
         {
           if (B_cfvalue.len > 511)
             {
               B_cfvalue.len = 511;
             }
           STRCPY_FROM_ORA(lachzArgs, B_cfvalue);
           
           /* structure stBGHGLOB                    */
           fovdPrintLog (LOG_DEBUG,"GetArgsFromDatabase: Args is %s\n", lachzArgs);
         }
     }
   
   return lachzArgs;
}

int GetTempAddressFromDatabase(int customer_id, tostAddress *ppstAddress)
{
  int rc = 0;
   
  fovdPrintLog (LOG_DEBUG, "Trying to get temporary address for %d\n", customer_id);
   
  EXEC SQL AT  :O_db_name
    SELECT  CCLINE1, CCLINE2, CCLINE3, CCLINE4, CCLINE5, CCLINE6, CCZIP
    INTO  
    :O_ccline1:O_ccline1_ind, 
    :O_ccline2:O_ccline2_ind, 
    :O_ccline3:O_ccline3_ind, 
    :O_ccline4:O_ccline4_ind, 
    :O_ccline5:O_ccline5_ind, 
    :O_cczip:O_cczip_ind
    FROM  CCONTACT_ALL
    WHERE CUSTOMER_ID = :customer_id AND CCBILLTEMP = 'X'; 
  
   if(sqlca.sqlcode != 0)
     {
       if(sqlca.sqlcode != SQL_NODATAFOUND)
         {
           rc = ESQL_SELBASEDIR;
           count_attempt = 0;
           sprintf(message, "GetTempAddressFromDatabase: SQL-Error");
           sqlerror(rc, message);
         }
       else /* no data */
         {
           rc = ESQL_NOMOREDATA;
           count_attempt = 0;
           sprintf(message, "GetTempAddressFromDatabase: temporary address not found in database\n");
           sqlerror(rc, message);
         } /* end if sqlca.sqlcode .... */
     } /* end if sqlca.sqlcode != 0 */
   
   if (rc == 0)
     {
       if (O_ccline1_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzLine1, O_ccline1);
         }
       
       if (O_ccline2_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzLine2, O_ccline2);
         }
       
       if (O_ccline3_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzLine3, O_ccline3);
         }
       
       if (O_ccline4_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzLine4, O_ccline4);
         }

       if (O_ccline5_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzLine5, O_ccline5);
         }

       if (O_cczip_ind != -1)
         {
           STRCPY_FROM_ORA(ppstAddress->sachzZip, O_cczip);
         }
     }
   
   return (rc);
}

int GetSocSecNoFromDatabase(int customer_id, char *ppchzSocSecNo)
{
  int rc = 0;
    
  fovdPrintLog (LOG_DEBUG, "Trying to get CUSTOMER_ALL.CSSOCIALSECNO for %d\n", customer_id);

  EXEC SQL AT  :O_db_name
    SELECT CSSOCIALSECNO 
    INTO :O_socsecno:O_socsecno_ind
    FROM CUSTOMER_ALL
    WHERE CUSTOMER_ID = :customer_id;

  if(sqlca.sqlcode != 0)
    {
      if(sqlca.sqlcode != SQL_NODATAFOUND)
        {
          rc = ESQL_SELBASEDIR;
          count_attempt = 0;
          sprintf(message, "GetSocSecNoFromDatabase: SQL-Error");
          sqlerror(rc, message);
        }
      else /* no data */
        {
          rc = ESQL_NOMOREDATA;
          count_attempt = 0;
          sprintf(message, "GetSocSecNoFromDatabase: temporary address not found in database\n");
          sqlerror(rc, message);
        } /* end if sqlca.sqlcode .... */
    } /* end if sqlca.sqlcode != 0 */

  if (rc == 0)
    {
      if (O_socsecno_ind == -1)
        {
          ppchzSocSecNo[0] = '\0';
        }
      else
        {
          STRCPY_FROM_ORA(ppchzSocSecNo, O_ccline3);      
        }
    }

  return rc;
};

/*************************************************************/
/*                                                           */
/* ABSTRACT : Inserts record to table EDS_BGH_REP with       */
/*            air time value from an invoice                 */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/*                                                           */
/*                                                           */
/*************************************************************/

int foiInsertAirTime(char *ppchzCustomerId, 
		     char *pachzContractNo, 
		     char *pachzInvoiceNo, 
                     char *pachzInvoiceDate, 
		     char *pachzOhEntryDate, 
		     char *pachzAirTimeValue, 
                     int poiSCCODE, 
		     int poiPLCODE)
{
  int rc = 0;
  
  fovdPrintLog (LOG_DEBUG, "Trying to insert values: %s, %s, %s, %s, %s, %s, %d, %d to table EDS_BGH_REP\n", 
                ppchzCustomerId, 
		pachzContractNo, 
		pachzInvoiceNo, 
		pachzInvoiceDate, 
		pachzOhEntryDate, 
                pachzAirTimeValue,  
		poiSCCODE, 
		poiPLCODE);
  
  O_dealer_customer_id = atoi(ppchzCustomerId);
  O_dealer_co_id = atoi(pachzContractNo);
  STRCPY_TO_ORA(O_dealer_ohrefnum, pachzInvoiceNo);
  STRCPY_TO_ORA(O_dealer_ohrefdate, pachzInvoiceDate);
  STRCPY_TO_ORA(O_dealer_ohentdate, pachzOhEntryDate);
  O_dealer_air_time_value = atof(pachzAirTimeValue);
  
  if (strlen(pachzInvoiceDate) == 8 && strlen(pachzOhEntryDate) == 8)
    {
      EXEC SQL AT :O_db_name
        INSERT INTO EDS_BGH_REP 
        (CUSTOMER_ID, CO_ID, REFDATE, REFNUM, MOA_AIRTIME, PLCODE, SCCODE, ENTDATE, OHENTDATE)
        VALUES
        (:O_dealer_customer_id, 
         :O_dealer_co_id, 
         TO_DATE(:O_dealer_ohrefdate, 'yyyymmdd'), 
         :O_dealer_ohrefnum, 
         :O_dealer_air_time_value,
         :poiPLCODE,
         :poiSCCODE,
         SYSDATE,
         TO_DATE(:O_dealer_ohentdate, 'yyyymmdd')); 
    }
  else if (strlen(pachzInvoiceDate) == 6 && strlen(pachzOhEntryDate) == 6)
    {
      EXEC SQL AT :O_db_name
        INSERT INTO EDS_BGH_REP 
        (CUSTOMER_ID, CO_ID, REFDATE, REFNUM, MOA_AIRTIME, PLCODE, SCCODE, ENTDATE, OHENTDATE)
        VALUES
        (:O_dealer_customer_id, 
         :O_dealer_co_id, 
         TO_DATE(:O_dealer_ohrefdate, 'rrmmdd'), /* windowing */ 
         :O_dealer_ohrefnum, 
         :O_dealer_air_time_value,
         :poiPLCODE,
         :poiSCCODE,
         SYSDATE,
         TO_DATE(:O_dealer_ohentdate, 'rrmmdd')); /* windowing */
    }
  else if (strlen(pachzInvoiceDate) == 8 && strlen(pachzOhEntryDate) == 6)
    {
      EXEC SQL AT :O_db_name
        INSERT INTO EDS_BGH_REP 
        (CUSTOMER_ID, CO_ID, REFDATE, REFNUM, MOA_AIRTIME, PLCODE, SCCODE, ENTDATE, OHENTDATE)
        VALUES
        (:O_dealer_customer_id, 
         :O_dealer_co_id, 
         TO_DATE(:O_dealer_ohrefdate, 'yyyymmdd'), 
         :O_dealer_ohrefnum, 
         :O_dealer_air_time_value,
         :poiPLCODE,
         :poiSCCODE,
         SYSDATE,
         TO_DATE(:O_dealer_ohentdate, 'rrmmdd')); /* windowing */
    }
  else if (strlen(pachzInvoiceDate) == 6 && strlen(pachzOhEntryDate) == 8)
    {
      EXEC SQL AT :O_db_name
        INSERT INTO EDS_BGH_REP 
        (CUSTOMER_ID, CO_ID, REFDATE, REFNUM, MOA_AIRTIME, PLCODE, SCCODE, ENTDATE, OHENTDATE)
	VALUES
        (:O_dealer_customer_id, 
         :O_dealer_co_id, 
         TO_DATE(:O_dealer_ohrefdate, 'rrmmdd'),  /* windowing */
         :O_dealer_ohrefnum, 
         :O_dealer_air_time_value,
         :poiPLCODE,
         :poiSCCODE,
         SYSDATE,
         TO_DATE(:O_dealer_ohentdate, 'yyyymmdd')); 
    }
  else
    {
      fovdPrintLog (LOG_CUSTOMER, "InvoiceDate len: %d, OhEntryDate len: %d\n", strlen(pachzInvoiceDate), strlen(pachzOhEntryDate));
      return -1;
    }
  
  if (sqlca.sqlcode != 0)
    {
      rc = ESQL_BILLINSERT;
      sqlerror (rc, "Inserting EDS_BGH_REP failed in function: foiInsertAirTime");
    }
  else
    {
      fovdPrintLog (LOG_DEBUG, "foiInsertAirTime: Inserted data into database\n");
      rc = 0;
    }
  
  return rc;
}


/*************************************************************/
/*                                                           */
/* ABSTRACT : Creates dynamic array with SIM cards           */
/*            belonging to one given customer                */
/*                                                           */
/* DESCRIPTION :                                             */
/*                                                           */
/*                                                           */
/* CALLED SUBROUTINES :                                      */
/*                                                           */
/*                                                           */
/* RETURN CODES :                                            */
/*                                                           */
/*   0                  : The function worked properly       */
/*   ERRORS                                                  */
/*                                                           */
/*                                                           */
/*************************************************************/

tostCustSim *gpstCustSimTab = NULL;
int goiCustSimTabSize = 0;

void fovdFreeCustSim()
{
  if (gpstCustSimTab != NULL)
    {
      free (gpstCustSimTab);
      gpstCustSimTab = NULL;
    }

  goiCustSimTabSize = 0;
}

int foiGetCustSim(int poiCustomerId)
{
  int	i, j;
  int rc = 0;
  tostCustSim *lpstCustSimTab, *lpstTmpTab;
  int loiCustSimTabSize;

  /*
   * Count number or records
   */
  
  T_count = 0;  
  O_sim_customer_id = poiCustomerId;

  EXEC SQL AT :O_db_name
    SELECT COUNT(*)
    INTO :T_count
    FROM SUB_MARKET SM,
    CUSTOMER_ALL CA,
    CCONTACT_ALL CC,
    CONTRACT_ALL CN,
    CONTR_DEVICES CD,
    CONTR_SERVICES_CAP CSP,
    DIRECTORY_NUMBER DN
    WHERE SM.SUBM_ID = CN.SUBM_ID 
    AND CA.CUSTOMER_ID = CC.CUSTOMER_ID 
    AND CA.CUSTOMER_ID = CN.CUSTOMER_ID 
    AND CN.CO_ID = CD.CO_ID 
    AND CSP.CO_ID = CN.CO_ID 
    AND CSP.DN_ID = DN.DN_ID
    AND CC.CCBILL = 'X'
    AND CA.CUSTOMER_ID = :O_sim_customer_id
    ORDER BY CN.CO_ID;    
  
  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      sprintf (message, "foiGetCustSim: Selected count(*) on sim failed.");
      sqlerror (rc, message);
    }

  /*
   * New array
   */
 
  lpstCustSimTab = (tostCustSim *) malloc (sizeof (tostCustSim) * (T_count + 1));
  if (lpstCustSimTab == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"foiGetCustSim\"");
      return ((int) ESQL_ALLOC);
    }
  
  lpstCustSimTab[T_count].soiIndex = -1;
  loiCustSimTabSize = T_count;
  
  if ((rc == 0) && (T_count != 0)) 
    {
      EXEC SQL OPEN Ccust_sim_list;      
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          count_attempt = 0;
          sprintf (message, "foiGetCustSim: Could not open Ccust_sim_list cursor ");
          sqlerror (rc, message);          
        }
      else 
        {        
          rc = 0;
        }

      for (i = 0; (i < T_count) && (rc == 0); i++) 
      {
        EXEC SQL FETCH Ccust_sim_list INTO
          :O_sim_custcode:O_sim_custcode_ind,
          :O_sim_ccfname:O_sim_ccfname_ind,
          :O_sim_cclname:O_sim_cclname_ind,
          :O_sim_co_id:O_sim_co_id_ind,
          :O_sim_co_activated:O_sim_co_activated_ind,
          :O_sim_subm_shdes:O_sim_subm_shdes_ind, 
          :O_sim_subm_des:O_sim_subm_des_ind,
          :O_sim_dn_num:O_sim_dn_num_ind,
          :O_sim_cd_sm_num:O_sim_cd_sm_num_ind;
        
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */                        
            SET_VARCHAR(lpstCustSimTab[i].sasnzCustcode, O_sim_custcode, O_sim_custcode_ind);
            SET_VARCHAR(lpstCustSimTab[i].sasnzCCFName, O_sim_ccfname, O_sim_ccfname_ind);
            SET_VARCHAR(lpstCustSimTab[i].sasnzCCLName, O_sim_cclname, O_sim_cclname_ind);
            SET_INT(lpstCustSimTab[i].soiCoId, O_sim_co_id, O_sim_co_id_ind);
            SET_VARCHAR(lpstCustSimTab[i].sasnzCoActivated, O_sim_co_activated, O_sim_co_activated_ind); 
            SET_VARCHAR(lpstCustSimTab[i].sasnzSubmShdes, O_sim_subm_shdes, O_sim_subm_shdes_ind); 
            SET_VARCHAR(lpstCustSimTab[i].sasnzSubmDes, O_sim_subm_des, O_sim_subm_des_ind); 
            SET_VARCHAR(lpstCustSimTab[i].sasnzDnNum, O_sim_dn_num, O_sim_dn_num_ind); 
            SET_VARCHAR(lpstCustSimTab[i].sasnzCdSmNum, O_sim_cd_sm_num, O_sim_cd_sm_num_ind);             
            break;
            
          case SQL_NODATAFOUND:	/* read whole table */
            rc = SQL_NODATAFOUND;            
            break;
            
          default:			/* some error */
            rc = sqlca.sqlcode; 
            break;
          }
      } /* of for .. */
      
      EXEC SQL CLOSE  Ccust_sim_list;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;          
          sprintf (message, "foiGetCustSim: Could not close Ccust_sim_list cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */        
        }
    } /* if (rc == 0) ... */

  if (gpstCustSimTab != NULL)
    {
      lpstTmpTab = (tostCustSim *) malloc (sizeof (tostCustSim) * (T_count + 1 + goiCustSimTabSize));
      if (lpstTmpTab == NULL) 
        {
          macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"foiGetCustSim\"");
          return ((int) ESQL_ALLOC);
        }
      
      i = 0;
      if (gpstCustSimTab != NULL)
        {
          while (i++ < goiCustSimTabSize)
            {
              memcpy (&lpstTmpTab[i], &gpstCustSimTab[i], sizeof(tostCustSim));
            }
          
          free(gpstCustSimTab);          
        }
 
      for (j = 0; j <= T_count; j++, i++)
        {
          memcpy(&lpstTmpTab[i], &lpstCustSimTab[j], sizeof(tostCustSim));  
        }
      
      free (lpstCustSimTab);

      gpstCustSimTab = lpstTmpTab;
      goiCustSimTabSize = T_count + goiCustSimTabSize;
    }
  else
    {
      gpstCustSimTab = lpstCustSimTab;
      goiCustSimTabSize = T_count;
    }

  return rc;
}


int foiIsPaymentResp(int customer_id)
{
  int rc = 0;
  char lachzPaymntresp[2];

  EXEC SQL AT  :O_db_name
    SELECT PAYMNTRESP 
    INTO :O_sim_paymntresp:O_sim_paymntresp_ind
    FROM CUSTOMER_ALL
    WHERE CUSTOMER_ID = :customer_id;

  if(sqlca.sqlcode != 0)
    {
      if(sqlca.sqlcode != SQL_NODATAFOUND)
        {
          rc = sqlca.sqlcode;          
          sprintf(message, "foiIsPaymentResp: SQL-Error");
          sqlerror(rc, message);
        }
      else
        {
          rc = sqlca.sqlcode;          
          sprintf(message, "foiIsPaymentResp: customer paymntresp attribute not found in database\n");
          sqlerror(rc, message);
        }
    }

  if (rc == 0)
    {
      SET_VARCHAR(lachzPaymntresp, O_sim_paymntresp, O_sim_paymntresp_ind);
      if (lachzPaymntresp[0] == 'X')
        {
          return TRUE;
        }
    }

  return FALSE;
}

int foiGetCustLevel(int customer_id, int *poiLevel)
{
  int rc = 0;
  char lachzLevel[3];

  EXEC SQL AT  :O_db_name
    SELECT CSLEVEL 
    INTO :O_sim_cslevel:O_sim_cslevel_ind
    FROM CUSTOMER_ALL
    WHERE CUSTOMER_ID = :customer_id;

  if(sqlca.sqlcode != 0)
    {
      rc = sqlca.sqlcode;  
      if(sqlca.sqlcode != SQL_NODATAFOUND)
        {
          sprintf(message, "foiGetCustLevel: SQL-Error");
          sqlerror(rc, message);
        }
      else
        {
          sprintf(message, "foiGetCustLevel: customer level not found in database\n");
          sqlerror(rc, message);
        }
    }

  if (rc == 0)
    {
      SET_VARCHAR(lachzLevel, O_sim_cslevel, O_sim_cslevel_ind);
      *poiLevel = atoi(lachzLevel);
    }

  return rc;
}

int goiSubCustTabSize = 0;
int *gpiSubCustTab = NULL;

int foiSubCustTab_AppendSubCusts(int poiCustomerId)
{
  int *lpiSubCustTab, loiSubCustTabSize;
  int *lpiTmpTab, loiTmpTabSize;
  int i, j, loiCount, rc, loiCustomerId;

  /*
   * Count expected number of customers
   */

  fovdPrintLog (LOG_DEBUG, "Counting subcustomers of customer: %d\n", poiCustomerId);
  loiCount = 0;    
  EXEC SQL AT :O_db_name
    SELECT COUNT(CUSTOMER_ID)
    INTO :loiCount
    FROM CUSTOMER_ALL
    WHERE CUSTOMER_ID_HIGH = :poiCustomerId;

  if (sqlca.sqlcode != 0) 
    {
      rc = ESQL_SELCOUNT;
      sprintf (message, "foiSubCustTab_AppendSubCusts: Selected count(*) on CUSTOMER_ALL failed.");
      sqlerror (rc, message);
    }

  fovdPrintLog (LOG_DEBUG, "Number of subcustomers of customer: %d\n", loiCount);

  if (loiCount == 0)
    {
      return 1;
    }

  /*
   * Allocate new memory for dynamic table
   */

  lpiSubCustTab = (int *) malloc ((T_count + 1) * sizeof(int));
  if (lpiSubCustTab == NULL) 
    {
      macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"foiSubCustTab_AppendSubCusts\"");
      return ((int) ESQL_ALLOC);
    }
  
  lpiSubCustTab[loiCount] = -1;
  loiSubCustTabSize = loiCount;

  /*
   * Load table from cursor
   */

  O_sim_customer_id = poiCustomerId;

  if ((rc == 0) && (loiCount != 0)) 
    {
      /*
       * Open cursor
       */
      
      fovdPrintLog (LOG_DEBUG, "Opening cursor\n");
      EXEC SQL OPEN Csub_cust_list;      
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_OPENTESTCURSOR;
          sprintf (message, "foiSubCustTab_AppendSubCusts: Could not open Csub_cust_list cursor ");
          sqlerror (rc, message);          
        }
      else 
        {        
          rc = 0;
        }

      /*
       * Fetch from cursor
       */

      for (i = 0; (i < loiCount) && (rc == 0); i++) 
      {
        fovdPrintLog (LOG_DEBUG, "Fetching from cursor\n");
        EXEC SQL FETCH Csub_cust_list INTO :loiCustomerId;
        switch (sqlca.sqlcode) 
          {
          case 0:			/* succesful read entry */                        
            lpiSubCustTab[i] = loiCustomerId;
            break;
            
          case SQL_NODATAFOUND:	/* read whole table */
            rc = SQL_NODATAFOUND;            
            break;
            
          default:			/* some error */
            rc = sqlca.sqlcode; 
            break;
          }
      } /* of for .. */

      /*
       * Close cursor
       */

      fovdPrintLog (LOG_DEBUG, "Closing cursor\n");
      EXEC SQL CLOSE  Csub_cust_list;
      if (sqlca.sqlcode != 0) 
        {
          rc = ESQL_CLOSETESTCURSOR;          
          sprintf (message, "foiSubCustTab_AppendSubCusts: Could not close Ccust_sim_list cursor ");
          sqlerror (rc, message);
        }
      else 
        {
          EXEC ORACLE OPTION (release_cursor=yes); /* remove link cursor-cursor's cache */        
        }
    } /* if (rc == 0) ... */

  /*
   * Append customers from local table to global one
   */

  fovdPrintLog (LOG_DEBUG, "Appending the list of customers to the main table\n");
  if (gpiSubCustTab != NULL)
    {
      /*
       * Create new dynamic table, 
       * add contents of two ones: old one and new one,
       * delete both of added tables.
       */
      
      lpiTmpTab = (int *) malloc (sizeof (int) * (loiCount + 1 + goiSubCustTabSize));
      if (lpiTmpTab == NULL) 
        {
          macErrorMessage (ESQL_ALLOC, CRITICAL, "Out of Memory in \"foiSubCustTab_AppendSubCusts\"");
          return ((int) ESQL_ALLOC);
        }
      
      /*
       * Old table
       */

      i = 0;
      if (gpiSubCustTab != NULL)
        {
          while (i++ < goiSubCustTabSize)
            {
              lpiTmpTab[i] = gpiSubCustTab[i];
            }
          
          free(gpiSubCustTab);          
        }
      
      /*
       * New table
       */

      for (j = 0; j <= loiCount; j++, i++)
        {
          lpiTmpTab[i] = lpiSubCustTab[j];
        }
      
      free (lpiSubCustTab);

      gpiSubCustTab = lpiTmpTab;
      goiSubCustTabSize = loiCount + goiSubCustTabSize;
    }
  else
    {
      /*
       * Fill empty table
       */
      
      gpiSubCustTab = lpiSubCustTab;
      goiSubCustTabSize = loiCount;
    }
      
  return 0;
}

int foiSubCustTab_Init(int poiCustomerId)
{
  if (gpiSubCustTab != NULL)
    {
      free (gpiSubCustTab);
    }

  goiSubCustTabSize = 1;
  gpiSubCustTab = malloc(sizeof(int) * 2);
  if (gpiSubCustTab == NULL)
    {
      return -1;
    }

  gpiSubCustTab[0] = poiCustomerId;
  gpiSubCustTab[1] = -1;

  return 0;
}

int foiGetSubCustTree(int poiCustomerId, int poiRejectPRP)
{
  int rc, loiLevel, i;

  /*
   * Only top customer may be PRP
   */

  if (poiRejectPRP == FALSE)
    {
      fovdPrintLog (LOG_DEBUG, "Init table of subcustomers\n");
      rc = foiSubCustTab_Init(poiCustomerId);
      if (rc != 0)
        {
          return rc;
        }
    }
      
  /*
   * Don't include subtrees of PRP customers
   */

  if (poiRejectPRP == TRUE && foiIsPaymentResp(poiCustomerId) == TRUE)
    {
      fovdPrintLog (LOG_DEBUG, "Rejected tree for customer: %d\n", poiCustomerId);
      return 0;
    }
  
  /*
   * The tail of table contains subcustomres of a given customer
   */
  
  fovdPrintLog (LOG_DEBUG, "Looking for subcustomers of customer: %d\n", poiCustomerId);
  rc = foiSubCustTab_AppendSubCusts(poiCustomerId);
  if (rc != 0)
    {      
      return 0;
    }
  
  fovdPrintLog (LOG_DEBUG, "Subcustomers table size: %d\n", goiSubCustTabSize);
  for (i = 0; i < goiSubCustTabSize; i++)
    {
      /*
       * This Table works like a Queue
       * all subcustomers will be appended
       */

      rc = foiGetSubCustTree(gpiSubCustTab[i], TRUE);
      if (rc != 0)
        {
          return rc;
        }      
    }

  return 0;
}

int foiIsContractAddress(int customer_id)
{
  int rc = 0;
  char lachzCSSumAddr[2];

  EXEC SQL AT  :O_db_name
    SELECT CSSUMADDR 
    INTO :O_sim_paymntresp:O_sim_paymntresp_ind
    FROM CUSTOMER_ALL
    WHERE CUSTOMER_ID = :customer_id;

  if(sqlca.sqlcode != 0)
    {
      if(sqlca.sqlcode != SQL_NODATAFOUND)
        {
          rc = sqlca.sqlcode;          
          sprintf(message, "foiIsContractAddress: SQL-Error");
          sqlerror(rc, message);
        }
      else
        {
          rc = sqlca.sqlcode;          
          sprintf(message, "foiIsContractAddress: customer cssumaddr attribute not found in database\n");
          sqlerror(rc, message);
        }
    }

  if (rc == 0)
    {
      SET_VARCHAR(lachzCSSumAddr, O_sim_paymntresp, O_sim_paymntresp_ind);
      if (lachzCSSumAddr[0] == 'C')
        {
          return 1;
        }
    }

  return 0;
}

#if 0 /*the template not used */ 
/*****************************************************************************
 *
 * Function name:	foiWorkParVal_LoadPart
 *
 * Function call:	rc = foiWorkParVal_LoadPart(laszDate, 
 *                                                  loiLen, 
 *                                                  lpiTab, 
 *                                                  &lpstSeqA, 
 *                                                  &lpstSeqB);
 *
 * Returns:	int
 *
 *              Value on success:
 *
 *                      0
 *
 *		Value on failure:
 *
 *                      -1  - can't load table 
 *
 * Arguments:	ppszDate, char * - YYYYMMDD format of the set period date end
 *              poiTabLen, int - the id table len
 *              ppiTab, int * - id table allocated externally
 *              pppstCustSeq, struct tostParValRecSeq ** - seq for co_id = NULL
 *              pppstCustSeq, struct tostParValRecSeq ** - seq for co_id != NULL
 *
 * Description: Two lists of records from WORKPARVAL are created, first one for
 *              records with CO_ID = NULL (no contract defined) and the other
 *              one for records with CO_ID != NULL (some contract id defined).
 *              The table of id must be used as the selection criterion.
 *              The number of selections to be done is: 2 * TabLen - for each
 *              WPARCODE and each CO_ID = {NULL, NOT NULL} one select. 
 *
 *****************************************************************************
 */

int foiWorkParVal_LoadPart(char *ppszDate, 
			   int poiTabLen, 
			   int *ppiTab, 
			   struct tostParValRecSeq **pppstCustSeq,
			   struct tostParValRecSeq **pppstContSeq)
{
  int rc = 0;
  int i;

  EXEC SQL BEGIN DECLARE SECTION;
  
  int O_workparval_wparcode;
  int O_workparval_customer_id;
  int O_workparval_co_id;
  VARCHAR O_workparval_finish_date[ 8];
  VARCHAR O_workparval_wparval    [80];
  VARCHAR O_workparval_field1     [80];
  VARCHAR O_workparval_field2     [80];
  VARCHAR O_workparval_field3     [80];
  VARCHAR O_workparval_field4     [80];
  VARCHAR O_workparval_field5     [80];
  
  EXEC SQL END DECLARE SECTION;

  for (i = 0; i < poiTabLen; i++)
    {
      
    }

  return rc;
}
#endif  /*the template not used */

/*****************************************************************************
 *
 * Function name:	foiWorkParVal_LoadPart
 *
 * Function call:	rc = foiWorkParVal_LoadPart(loszFinishDate, lpstSeqFirst)
 *
 * Returns:  success 
 *              0  if no data found in the database
 *              1  if data was loaded
 *           failure
 *              -1  no memory
 *              -2  SQL error
 *
 *
 * Arguments:	char *poszFinishDate - date in the form YYYYMMDD,
 *                                    the data for this date only will be loaded
 *
 *              tostWParValRecSeq **ppstSeqFirst - begining of the record sequence
 *
 * Description: The sequence of records from EDS_RIH_WORKPARVAL is created.
 *
 *****************************************************************************
 */
int  foiWorkParVal_LoadPart(char *poszFinishDate, tostWParValRecSeq **ppstSeqFirst)
{
    tostWParValRec  lostCurrentRec, *lpstTmpRec;
    tostWParValRecSeq *lpstSeqFirst = NULL, **lpstSeqLast, *lpstSeqTmp;

    int rc=0, loiRowCount;

    STRCPY_TO_ORA(O_WParValDate, poszFinishDate);

    fovdPrintLog(LOG_DEBUG, "Opening cursor for WPARCODE with date: %s\n", poszFinishDate);
    EXEC SQL OPEN CWParVal_cursor;
    if(sqlca.sqlcode != 0) {
	rc =   ESQL_OPENPARVALCURSOR;
	sprintf (message, "Open CWParVal Cursor: SQL-Error");
	sqlerror (rc, message);
	return -2;
    } else {
	fovdPrintLog(LOG_DEBUG, "Open cursor for WPARCODE with date: %s\n", poszFinishDate);
    }

    *ppstSeqFirst = NULL;
    loiRowCount = 0;

    while (rc == 0){
	fovdPrintLog(LOG_DEBUG, "Fetching from cursor for WPARCODE with date: %s\n", poszFinishDate);
	EXEC SQL FETCH CWParVal_Cursor INTO 
	    :O_WParValCode       :O_WParValCode_ind,
	    :O_WParValCustomerId :O_WParValCustomerId_ind,
	    :O_WParValCoId       :O_WParValCoId_ind,
	    :O_WParVal           :O_WParVal_ind,
	    :O_WParValDate       :O_WParValDate_ind,
	    :O_WParValField1     :O_WParValField1_ind,
	    :O_WParValField2     :O_WParValField2_ind,
	    :O_WParValField3     :O_WParValField3_ind,
	    :O_WParValField4     :O_WParValField4_ind,
	    :O_WParValField5     :O_WParValField5_ind;
	if(sqlca.sqlcode != 0) 
	{
	    if(sqlca.sqlcode != SQL_NODATAFOUND) 
	    {
		rc = ESQL_FETCHCURSOR;
		sprintf (message, "CWParVal Cursor: SQL-Error");
		sqlerror (rc, message);
		return -2;
	    }
	    else /* no more data */ 
	    {
		rc = ESQL_NOMOREDATA;
		fovdPrintLog (LOG_DEBUG, "foiWorkParVal_LoadPart: no more data\n");
	    } /* end no more data */
	}
	else
	{
	    if(-1 == O_WParValCode_ind || -1 == O_WParValCustomerId_ind)
	    {
		fovdPrintLog(LOG_NORMAL, "foiWorkParVal_LoadPart: null value in the table\n");
		return -1;
	    }
	    /*
	     * the new item in the sequence
	     */
	    if(NULL == (lpstSeqTmp=malloc(sizeof(tostWParValRecSeq))))
	    {
		fovdPrintLog(LOG_NORMAL, "foiWorkParVal_LoadPart: I can not get memory for the node\n");
		return -1;
	    } 
	    lpstSeqTmp->spstNext = NULL;
	    /*
	     * The new data structure for the item
	     */
	    if(NULL == (lpstTmpRec=malloc(sizeof(tostWParValRec))))
	    {
		fovdPrintLog(LOG_NORMAL, "foiWorkParVal_LoadPart: I can not get memory for the record\n");
		return -1;
	    } 
	    STRCPY_FROM_ORA(lpstTmpRec->soszWParCode, O_WParValCode);
	    STRCPY_FROM_ORA(lpstTmpRec->soszCustomerId, O_WParValCustomerId );
	    SET_VARCHAR(lpstTmpRec->soszCoId, O_WParValCoId, O_WParValCoId_ind);
	    STRCPY_FROM_ORA(lpstTmpRec->soszWParValFinishDate, O_WParValDate);
	    SET_VARCHAR(lpstTmpRec->soszWParVal, O_WParVal, O_WParVal_ind);
	    SET_VARCHAR(lpstTmpRec->soszWParField1, O_WParValField1, O_WParValField1_ind);
	    SET_VARCHAR(lpstTmpRec->soszWParField2, O_WParValField2, O_WParValField2_ind);
	    SET_VARCHAR(lpstTmpRec->soszWParField3, O_WParValField3, O_WParValField3_ind);
	    SET_VARCHAR(lpstTmpRec->soszWParField4, O_WParValField4, O_WParValField4_ind);
	    SET_VARCHAR(lpstTmpRec->soszWParField5, O_WParValField5, O_WParValField5_ind);
	    lpstSeqTmp->spstRec = lpstTmpRec;
	    fovdPrintLog(LOG_DEBUG,
			 "foiWorkParVal_LoadPart, record loaded:\n%s %s %s %s %s %s %s %s %s %s\n",
			 lpstTmpRec->soszWParCode,
			 lpstTmpRec->soszCustomerId,
			 lpstTmpRec->soszCoId,
			 lpstTmpRec->soszWParValFinishDate,
			 lpstTmpRec->soszWParVal,
			 lpstTmpRec->soszWParField1,
			 lpstTmpRec->soszWParField2,
			 lpstTmpRec->soszWParField3,
			 lpstTmpRec->soszWParField4,
			 lpstTmpRec->soszWParField5);
	    /*
	     * link the new item to the end of the sequence
	     */
	    if(*ppstSeqFirst == NULL)
	    {
		*ppstSeqFirst = lpstSeqTmp;
	    }
	    else
	    {
		*lpstSeqLast = lpstSeqTmp;
	    }
            lpstSeqLast = &(lpstSeqTmp->spstNext); 
	}
    }

    EXEC SQL OPEN CWParVal_cursor;
    if(sqlca.sqlcode != 0){
	rc =   ESQL_CLOSEPARVALCURSOR;
	sprintf (message, "Close CWParVal Cursor: SQL-Error");
	sqlerror (rc, message);
	return -2;
    } else {
	fovdPrintLog(LOG_DEBUG, "Cose cursor for WPARCODE\n");
    }

    return  (NULL == *ppstSeqFirst) ? 0 : 1 ;
}

/* THE END ***************************************************/








